%
% dia3.tex
% 
% Copyright 2014 Rony J. Letona <rony@zronyj.com>
% 
% This program is free software; you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation; either version 2 of the License, or
% any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
% MA 02110-1301, USA.
%

\documentclass[10pt,letterpaper]{article}
\usepackage[latin1]{inputenc}
\usepackage[spanish]{babel}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{color}
\usepackage{float}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\author{Rony J. Letona}
\title{Taller de Qu\'imica Computacional Aplicada: D\'ia 3}
\definecolor{light-gray}{gray}{0.90}

\newcommand{\tab}[1]{\hspace{.2\textwidth}\rlap{#1}}

\newcommand{\inlinecode}[1]{
\colorbox{light-gray}{\texttt{#1}}
}

\newsavebox{\selvestebox}
\newenvironment{Code}
{
\begin{lrbox}{\selvestebox}%
\begin{minipage}{\dimexpr\columnwidth-2\fboxsep\relax}
\fontfamily{\ttdefault}\selectfont
}
{\end{minipage}\end{lrbox}%
\begin{center}
\colorbox{light-gray}{\usebox{\selvestebox}}
\end{center}
}

\newcommand{\Picture}[1]
{
	\begin{figure}[H]
	\begin{flushleft}
	\includegraphics[width=\columnwidth]{#1}
	\end{flushleft}
	\end{figure}
}

\begin{document}
\maketitle

\section{Ejercicios con el Sistema de Control de Revisi\'on - Git}
Al comenzar a trabajar en un proyecto en computaci\'on, generalmente se trabaja con archivos sencillos de texto, como hemos visto anteriormente. Estos tienen el c\'odigo que escribimos y al compilarlos/interpretarlos y ejecutarlos, resultan en programas. Todo funciona as\'i. A veces el c\'odigo en los archivos es comprensible, a veces no lo es porque no es para que lo entendamos nosotros sino el ordenador. Sin embargo, a todos nos ha pasado que borramos un archivo importante o que cambiamos algo que no deb\'iamos de cambiar y no hay manera de recuperarlo. Desde documentos como reportes de laboratorio hasta cartas, siempre nos pasa en alguna ocasi\'on que perdemos informaci\'on importante. Para evitar esto en ambientes de desarrollo, se dise\~n\'o una alternativa.\\

Git es la soluci\'on m\'as eficiente. Es un sistema en el que cada revisi\'on o versi\'on de un archivo se va guardando gradualmente cuando nosotros lo indiquemos; se lleva registro de cu\'ales cambios se hicieron y de cu\'ando se hicieron. Es un cuaderno de laboratorio digital! No nos salvar\'a un programa a medio escribir si perdemos acceso a nuestros documentos o si deseamos trabajar en colaboraci\'on con m\'as personas. Es un sistema para llevar autom\'aticamente registro del trabajo realizado. Lo usan grandes empresas, as\'i como peque\~nas iniciativas en sus proyectos. Y no se tiene que limitar a software, puede tratarse de libros, art\'iculos, bases de datos peque\~nas y cualquier otra cosa que sufra cambios con el tiempo o requiera ser compartida. Por ello, y por otras razones que veremos m\'as adelante, vamos a hacer algunos ejercicios con el sistema git.

\section{Creando un repositorio}
Lo primero que haremos ser\'a crear un repositorio. Esto \'ultimo es un lugar en donde vamos a colocar todos los archivos y documentos en los que estamos trabajando. Crear uno es algo que podemos hacer de dos maneras: en nuestro ordenador o en la nube\footnote{Decimos \emph{en la nube} para referirnos a que est\'a en internet, accesible a todos.}. Para hacer lo primero, vamos a abrir una Terminal y escribir \inlinecode{git init NombreDelProyecto}, en donde \textbf{NombreDelProyecto} es el nombre que nosotros querramos darle a la carpeta en donde colocaremos todos los archivos y documentos de nuestro proyecto. Luego entramos a la carpeta con \inlinecode{cd NombreDelProyecto} y aqu\'i podemos comenzar a trabajar.\\

La otra manera de comenzar un repositorio es accesando a una p\'agina como \href{https://github.com/}{GitHub}, \href{https://gitlab.com/}{GitLab}, \href{https://mercurial.selenic.com/}{Mercurial}, \href{https://bitbucket.org/}{BitBucket}, \href{http://sourceforge.net/}{SourceForge}, \href{http://www.codeplex.com/}{CodePlex}, etc. y creando un usuario en ella. Es conveniente mencionar que GitHub es la m\'as famosa, aunque de las anteriormente expuestas quiz\'a GitLab es la mejor para nuestros fines. Por eso, vamos a ir a GitLab, crearemos un usuario y seguiremos las instrucciones para crear un proyecto nuevo. Idealmente si nuestro proyecto tiene un nombre f\'acil y lo hacemos p\'ublico para que todos lo puedan ver y trabajar en \'el. Cuando nuestro repositorio ya est\'e creado, vamos a proveer quien nos est\'a dando el taller con nuestro usuario, y luego vamos a continuar.

\section{Clonando un repositorio}
Una vez logramos crear un repositorio en la nube, es momento de sincronizarlo con nuestro ordenador. Para ello vamos a ver que el proyecto que creamos en GitLab nos ofrece una direcci\'on \emph{HTTPS}. Vamos a copiar esta direcci\'on y vamos a escrbir lo siguiente en nuestra Terminal: \inlinecode{git clone} y luego vamos a pegar la direcci\'on que acabamos de copiar. Presionaremos enter y veremos como es que git crea una copia del proyecto en nuestro ordenador. Claro, como no hay nada en el proyecto a\'un, git nos advertir\'a de esto y solo crear\'a la carpeta. Ahora que ya hemos comenzado, vamos a ver realmente para qu\'e es que nos sirve git.

\section{Configurando a git}
Ahora viene una parte muy importante. Esta parte no la podemos ignorar o vamos a tener muchos problemas adelante. Debemos decirle a git qui\'en es el responsable en esta carpeta y el correo electr\'onico al que debe de referirse. Para eso, con la Terminal, debemos colocarnos \emph{dentro} de la carpeta en donde vamos a trabajar. Ya all\'i, escribiremos esto en la terminal: \inlinecode{git config user.name "\textbf{Su nombre y apellido}"} De esta forma ya especificamos el nombre de quien est\'a trabajando all\'i. Ahora nos toca especificar un correo electr\'onico. Para ello escribiremos esto: \inlinecode{git config user.email \textbf{su\_correo@electronico.com}} Con esto ya hecho, al momento de guardar cambios, no habr\'a tanto problema. La idea es que siempre se pueda identificar qui\'en hizo qu\'e y c\'omo avanz\'o.

\section{Diferentes directorios de trabajo}
Git, m\'as que un sistema para ir guardando copias de seguridad, es un sistema para ir guardando diferentes versiones de un trabajo y en colaboraci\'on. C\'omo es eso? Cada cambio grande que vamos haciendo, lo vamos guardando y poni\'endole un mensaje de qu\'e es lo que logramos en ese momento. Para llevar esto a cabo, git segmenta todo en 3 supuestos \textit{directorios}. El primero es donde estamos trabajando y guardando nuestro trabajo; un directorio normal al que llamamos \emph{directorio de trabajo}. Luego est\'a el \textit{directorio} a donde vamos agregando las cosas que vamos guardar como versi\'on: el directorio \emph{index} o \emph{stage}\footnote{Por este nombre es que se dice \emph{staging} a los archivos que vamos guardando poco a poco.}. Luego est\'a el \'ultimo directorio que contiene a los archivos y documentos que deseamos declarar como una versi\'on nueva completa. Es como un grupo de archivos y documentos que, al ser terminados, se van guardando como un cambio completo, con un mensaje determinado y con cierto n\'umero de versi\'on. A esto se le llama \emph{HEAD}. Finalmente, cuando mandamos todo esto a la nube, hablamos de que sincronizamos o \emph{empujamos} nuestro trabajo al repositorio. La idea ahora ser\'a ir comprendiendo c\'omo trasladamos la informaci\'on de un directorio a otro para ayudarnos en nuestro trabajo.

Colocar dibujitos aqui.

\section{Actualizando directorios: add \& commit}
Para dar una buena idea de c\'omo usar git, vamos a hacer un proyecto simple. En un nuevo repositorio, clonado a nuestro ordenador, vamos a crear un documento nuevo: \textit{gases.py} Ahora, este documento est\'a en nuestro directorio de trabajo o \textbf{w}orking \textbf{d}irectory (WD). Digamos que deseamos pasar este documento de WD a stage. En ese caso, solo escribimos \inlinecode{git add gases.py} en nuestra terminal\footnote{Asegur\'emonos de estar \emph{dentro} del directorio creado con git al clonar el repositorio.} y ya vamos a haber pasado de WD a stage. Esto se puede hacer con cada nuevo documento o archivo, pero si se va a agregar varios simult\'aneamente, la expresi\'on \inlinecode{git add --all} jam\'as puede ser sobrevalorada.\\

Continuando con nuestro peque\~no proyecto, vamos a abrir el documento \textit{gases.py} y vamos a escribir un poco en \'el. Este peque\~no programa nos servir\'a para calcular alguna variable seg\'un el principio de los gases ideales, al prove\'ersele lo dem\'as. Lo primero que debemos hacer es pensar en qu\'e necesitamos en el programa. Evidentemente vamos a requerir:

\begin{itemize}
\item Una funci\'on que le solicite los datos al usuario.
\item Una funci\'on que calcule el resultado de la operaci\'on solicitada.
\item El programa principal con alguna manera de representar los resultados.
\end{itemize}

Entonces, la primera funci\'on se puede ver as\'i:

\begin{Code}
def datos():\\
\hspace*{8mm}print("*** Gases Ideales ***")\\
\hspace*{8mm}print("\ \ \ \ \ P\ V=n\ R\ T")\\
\hspace*{8mm}print("\ \ \ \ \ 1\ 2\ 3\ \ \ 4")\\
\hspace*{8mm}opcion = input("Seleccionar variable a calcularse:\ ")\\
\hspace*{8mm}if opcion >\ 4 or opcion <\ 1:\\
\hspace*{16mm}print("\ \hspace*{-2mm}Opcion invalida!")\\
\hspace*{16mm}return -1, 0, 0, 0\\
\hspace*{8mm}if not (opcion == 1):\\
\hspace*{16mm}presion = float(raw\_input("\ \hspace*{-2mm}Ingresar presion en atmosferas:\ "))\\
\hspace*{8mm}else:\\
\hspace*{16mm}presion = 0\\
\hspace*{8mm}if not (opcion == 2):\\
\hspace*{16mm}volumen = float(raw\_input("\ \hspace*{-2mm}Ingresar volumen en litros:\ "))\\
\hspace*{8mm}else:\\
\hspace*{16mm}volumen = 0\\
\hspace*{8mm}if not (opcion == 3):\\
\hspace*{16mm}moles = float(raw\_input("\ \hspace*{-2mm}Ingresar cantidad de materia en moles:\ "))\\
\hspace*{8mm}else:\\
\hspace*{16mm}moles = 0\\
\hspace*{8mm}if not (opcion == 4):\\
\hspace*{16mm}temperatura = float(raw\_input("\ \hspace*{-2mm}Ingresar temperatura en Kelvin:\ "))\\
\hspace*{8mm}else:\\
\hspace*{16mm}temperatura = 0\\
\hspace*{8mm} return opcion, presion, volumen, moles, temperatura
\end{Code}

Con esto vamos a tener ya la funci\'on que nos captura los datos del usuario y nos los tiene listos para ser calculados. Ahora es un buen momento para a\~nadir los cambios al stage a trav\'es de \inlinecode{git add gases.py} Sin embargo, es un buen momento para guardar esto de una manera m\'as profunda, porque realmente esta fue una funci\'on larga. Lo que haremos ahora ser\'a enviar los cambios a HEAD. Eso implica que estos cambios ya merecen un peque\~no mensaje sobre lo que hemos hecho. Es por esto que vamos a proceder de la siguiente manera.\\

Primero vamos a escribir lo siguiente en la terminal: \inlinecode{git commit -m 'Guardando mi primera funci\'on'} Luego vamos a ver c\'omo es que git guarda todo en HEAD. Es un proceso simple que solo muestra algunos de los pasos realizados al hacer \emph{commit} de los cambios. De esta manera git ya tiene algo parecido a una \textit{copia de seguridad} en su directorio reservado. Lo que haremos ahora ser\'a escribir otra funci\'on: la funci\'on que calcula.

\begin{Code}
def calcular(opc, P, V, n, T):\\
\hspace*{8mm}R = 0.0821\\
\hspace*{8mm}if opc == 1:\\
\hspace*{16mm}return n * R * T / V\\
\hspace*{8mm}elif opc == 2:\\
\hspace*{16mm}return n * R * T / P\\
\hspace*{8mm}elif opc == 3:\\
\hspace*{16mm}return P * V / (R * T)\\
\hspace*{8mm}elif opc == 4:\\
\hspace*{16mm}return P * V / (R * n)\\
\hspace*{8mm}else:\\
\hspace*{16mm}return "\ \hspace*{-1.5mm}Opcion mal ingresada."
\end{Code}

Perfecto! Con esto ya tenemos una funci\'on que al ingresarle las opciones, nos calcula la variable faltante. Es importante que al terminar de escribirla, nuestro instinto sea el de guardar nuestro trabajo, a\~nadirlo a \textit{stage} y luego a \textit{HEAD}. Para ello vamos a volver a escribir \inlinecode{git add gases.py} y despu\'es de ejecutar ese comando, vamos a escribir el siguiente: \inlinecode{git commit} Si nos damos cuenta, al ejecutar este comando, git abre un editor de texto (que ya deber\'iamos de conocer) para escribir nuestro mensaje all\'i. La ventaja es clara: nos podemos extender, usar caracteres raros, tener varias l\'ineas, etc. Es mucho m\'as c\'omodo escribirlo aqu\'i. Una vez hayamos escrito un mensaje para nuestra nueva funci\'on, vamos a presionar \textbf{Ctrl} + \textbf{X}, luego \textbf{Y} para aceptar los cambios, y finalmente \textbf{Enter} para aceptar el nombre que git le est\'a dando al archivo en el que va nuestro mensaje.\\

Si nos damos cuenta, este proceso de agregar y hacer \emph{commit} a cada funci\'on que terminamos es un proceso repetitivo que debemos ir haciendo peri\'odicamente para no perder nuestros avances. Tambi\'en nos sirve para ir catalogando cada parte del c\'odigo a manera de saber qu\'e se hizo en qu\'e momento y c\'omo. Antes de terminar con nuestro peque\~no programa, vamos a ver c\'omo enviamos cambios a la nube.

\section{Enviar cambios a la nube: push}
Esta parte es quiz\'a la m\'as interesante para muchos. Generalmente git se queda en ir creando copias y versiones de nuestro trabajo en progreso, pero todo cambia y se vuelve mejor cuando lo sincronizamos con la nube. En otras palabras, lo vamos a enviar a un servidor en donde tendremos todo ordenado y listo. Las ventajas de esto son varias:

\begin{itemize}
\item Tendremos una copia de nuestro trabajo aunque algo malo le pase a nuestro ordenador.
\item Muchas otras personas podr\'an colaborar con nosotros en el proyecto que estamos haciendo.
\item Podemos trabajar en el mismo proyecto desde diferentes ordenadores y lugares.
\item Podremos visualizar de mejor manera los cambios realizados por nosotros u otras personas.
\item Todo queda en una plataforma de m\'as f\'acil acceso y m\'as universal: internet.
\end{itemize}



\section{Ramas}
checkout -b (crear)
checkout
checkout -d (borra)
checkout origin

\section{Actualizar y fusionar: pull \& merge}
pull
merge (rama)

\section{Revisar cambios: diff \& status}
diff
status

\section{Reemplazar cambios locales: checkout, fetch y \& reset}
checkout -- (archivo)

Para ello vamos a comenzar con un proyecto en particular y vamos a irlo desarrollando poco a poco entre todos los presentes.

\section{Proyecto}
El proyecto en el que vamos a trabajar ya est\'a creado en un repositorio de GitLab. Por esta raz\'on solo vamos a clonar el proyecto de esta direcci\'on: https://gitlab.com/zronyj/TQCA\_ej.git Al ya haber clonado el proyecto, entraremos en la carpeta correspondiente y comenzaremos a trabajar. Lo primero que haremos ser\'a entrar a la carpeta \textbf{Users} y crear un documento de texto que contenga nuestro nombre completo, nuestra fecha de cumplea\~nos y si somos estudiantes, catedr\'aticos o investigadores en una l\'inea diferente cada cosa. Luego vamos a guardar este documento bajo el siguiente nombre: \emph{apellidoNombre.txt} en donde el apellido y el nombre son \textbf{tu} apellido y \textbf{tu} nombre. Finalmente nos saldremos de la carpeta \textbf{Users} y quedaremos listos para el siguiente paso.\\

En los d\'ias anteriores hemos visto algunos principios b\'aiscos para programar rutinas o peque\~nos programas. Hoy vamos a comenzar con uno que nos va a servir para ejemplificar el uso de git. Nos vamos a dividir en 4 grupos y vamos a intentar hacer 4 programas sencillos; uno por grupo. De esta manera vamos a entender mejor c\'omo es que funciona git. Los programas son:

\begin{enumerate}
\item \textbf{Fisicoqu\'imica:} peque\~no programa al que le demos la entalp\'ia, entrop\'ia y temperatura (en Kelvin) de los productos y de los reactivos de una reacci\'on, y este nos muestre las diferencias calculadas entre reactivos y productos para entalp\'ia $\Delta H$, entrop\'ia $\Delta S$ y energ\'ia libre de Gibbs $\Delta G$. Como dato importante, esta f\'ormula puede ser \'util: $\Delta G = \Delta H - T \cdot \Delta S$ Y para calcular diferencias, solo basta con una simple resta: $\Delta H = H_{prods} - H_{reacts}$
\item \textbf{An\'alisis:} peque\~no programa que calcula el pH de una soluci\'on de \'acido ac\'etico solo introduci\'endole el volumen de \'acido ac\'etico agregado $V_{HAc}$, la concentraci\'on del mismo $\left[ HAc \right]$ y el volumen de agua sobre el que se est\'a agregando $V_{H_2 O}$. Como datos importantes, este equilibrio viene dado por: $K = \frac{\left[ H^+ \right] \left[ Ac^- \right]}{\left[ HAc \right]}$ Para calcular concentraciones a vol\'umenes nuevos, se hace esto: $\left[ HAc \right]_{nueva} = \frac{\left[ HAc \right] \cdot V_{HAc}}{V_{H_2 O} + V_{HAc}}$ Y el pH se calcula de esta manera: $pH = - \log_{10} \left( \left[ H^+ \right] \right)$ La constante es $K = 1.77 \cdot 10^{-5}$
\item \textbf{Org\'anica:} peque\~no programa que calcula la cantidad de insaturaciones en una mol\'ecula, dada la f\'ormula. La mol\'ecula puede tener hal\'ogenos, ox\'igeno y/o nitr\'ogeno. Como dato importante, la f\'ormula para hacer esto se ve de la siguiente manera: $IDH = C - \frac{H}{2} + \frac{N}{2} + 1$ en donde $C$ es el n\'umero de \textbf{c}arbonos, $H$ es el n\'umero de \textbf{h}idr\'ogenos o \textbf{h}al\'ogenos y $N$ es el n\'umero de \textbf{n}itr\'ogenos. El programa tiene que aceptar el ingreso de los elementos uno por uno.
\item \textbf{Inorg\'anica:} peque\~no programa que calcula la densidad de un metal basado en el volumen de la unidad cristalina m\'as peque\~na. Para ello se indica si la unidad es c\'ubica simple (\emph{PCC}), c\'ubica centrada en el cuerpo (\emph{BCC}) o c\'ubica centrada en las caras (\emph{FCC}). Como dato importante se ha de mencionar que la f\'ormula para calcular el volumen de la PCC es: $V_{PCC} = \left( 2 r \right)^3$, la f\'ormula para calcular la BCC es: $V_{BCC} = \left( \frac{4 \sqrt{3} r}{3} \right)^3$ y la f\'ormula para calcular FCC es $V_{FCC} = \left( 2 \sqrt{2} r \right)^3$. Claro, $r$ es el radio at\'omico del metal del que deseamos calcular. En la PCC hay 1 \'atomo del metal en cuesti\'on. En la BCC hay 2 \'atomos. Y en la FCC hay 4 \'atomos. Y claro, la densidad es siempre: $\rho = \frac{m}{V}$
\end{enumerate}

No nos vayamos a complicar la vida haciendo estos programas, la idea es mantener la simplicidad. 

\section{Comentarios finales}

\newpage

\subsection{Glosario de comandos sencillos}
\begin{small}
\begin{itemize}
\item \textbf{git config}: configura git con tu nombre, tu direcci\'on de correo y tu editor de texto preferido.
\item \textbf{git init}: inicia un nuevo proyecto en git de manera local; un nuevo repositorio.
\item \textbf{git clone}: descarga los contenidos de un repositorio ya existente a tu ordenador y los deja listos para poder trabajar con ellos.
\item \textbf{git status}: revisa el estado actual de los archivos en el repositorio en comparaci\'on al \'ultimo commit.
\item \textbf{git diff}: muestra claramente las diferencias entre el estado actual de los archivos en el repositorio con respecto al \'ultimo commit. Muestra las diferencias l\'inea por l\'inea.
\item \textbf{.gitignore}: archivo que contiene el listado de todos los archivos del proyecto que deben ser ignorados por git.
\item \textbf{git commit}: guarda los cambios realizados a los archivos como una revisi\'on. Crea un registro y un \emph{id} que identifica a esa revisi\'on.
\item \textbf{git push}: empuja (sube) los commits locales a GitHub.
\item \textbf{git pull}: jala (descarga) los archivos del proyecto en GitHub, actualizando el estado de estos en nuestro ordenador.
\item \textbf{git log}: muestra toda la actividad de commits que ha habido en un repositorio/proyecto.
\item \textbf{git branch}: muestra a todas las ramas existentes o, si se le agrega un nombre despu\'es del comando, se crea una rama nueva en el proyecto.
\item \textbf{git merge}: une a una rama existente con otra rama que se debe de especificar como argumento del comando.
\item \textbf{git checkout}: si como argumento se agrega el nombre de una rama, se habr\'a trasladado a esa rama. Si como argumento se agrega el \emph{id} de un commit o la distancia de la cabeza a un commit con \inlinecode{HEAD$\sim$\#}, entonces nos situaremos en el commit seleccionado y podremos ver el estado del proyecto en ese momento.
\end{itemize}
\end{small}

\section*{Licencia}

\noindent \includegraphics{img/cc_big.png}

\noindent Taller de Qu\'imica Computacional Aplicada by \href{http://github.com/zronyj/TQCA}{Rony J. Letona} is licensed under a \href{http://creativecommons.org/licenses/by-sa/4.0/}{Creative Commons Attribution-ShareAlike 4.0 International License}.
Based on a work at \url{http://github.com/swcarpentry/bc}.

\end{document}
