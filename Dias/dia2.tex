%
% dia2.tex
% 
% Copyright 2014 Rony J. Letona <rony@zronyj.com>
% 
% This program is free software; you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation; either version 2 of the License, or
% any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
% MA 02110-1301, USA.
%

\documentclass[10pt,letterpaper]{article}
\usepackage[latin1]{inputenc}
\usepackage[spanish]{babel}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{color}
\usepackage{float}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\author{Rony J. Letona}
\title{Taller de Qu\'imica Computacional Aplicada: D\'ia 2}
\definecolor{light-gray}{gray}{0.90}

\newcommand{\tab}[1]{\hspace{.2\textwidth}\rlap{#1}}

\newcommand{\inlinecode}[1]{
\colorbox{light-gray}{\texttt{#1}}
}

\newsavebox{\selvestebox}
\newenvironment{Code}
{
\begin{lrbox}{\selvestebox}%
\begin{minipage}{\dimexpr\columnwidth-2\fboxsep\relax}
\fontfamily{\ttdefault}\selectfont
}
{\end{minipage}\end{lrbox}%
\begin{center}
\colorbox{light-gray}{\usebox{\selvestebox}}
\end{center}
}

\newcommand{\Picture}[1]
{
	\begin{figure}[H]
	\begin{flushleft}
	\includegraphics[width=\columnwidth]{#1}
	\end{flushleft}
	\end{figure}
}

\begin{document}
\maketitle

\section{Ejercicios con una Base de Datos Relacional - SQLite}
Una tabla es, generalmente, la mejor forma de ordenar datos cuando queremos almacenarlos o representarlos. Sin embargo, a todos los que hemos trabajado con muchos datos, nos suele suceder que queremos aislarlos o filtrarlos de alguna manera para analizar alguna tendencia particular. Microsoft Excel nos deja ordenar los datos, pero no nos deja aislarlos, ni mucho menos filtrarlos en base a alguna condici\'on. Y hay otro problema a\'un! Una tabla de Excel o de Calc tiene l\'imites bajos de almacenamiento de datos. Qu\'e hacer ahora? All\'i entramos al reino de las bases de datos.\\

Una base de datos (o DB por sus siglas en ingl\'es) es simplemente un lugar donde meter informaci\'on en gran cantidad. Existen de varios tipos, pero en particular hablaremos de las bases de datos relacionales. En estas, los datos se almacenan de forma ordenada en tablas gigantes. Para accesar los datos se utiliza un lenguaje muy particular llamado lenguaje de consulta estructurado, o SQL por sus siglas en ingl\'es. Este permite hacer una serie de operaciones que van desde insertar o eliminar un dato en espec\'ifico, hasta filtrar todos los datos almacenados y calcular propiedades de los mismos. Guardar estos datos para representarlos en gr\'aficas o para posteriores an\'alisis tambi\'en se puede hacer, logrando as\'i que muchos datos no se queden en datos, sino que se pueda hacer inferencias sobre ellos.\\

Para comprender mejor c\'omo es que funciona esto debemos de considerar que una DB no es solo el lugar de almacenamiento, sino que tambi\'en hay un \emph{administrador} de la DB que es el programa que interpreta el SQL y hace las consultas y los c\'alculos. Por eso es que generalmente las DBs no son un archivo con toda la informaci\'on nada m\'as. Una DB es m\'as compleja que eso. Sin embargo, por diferentes razones y circunstancias existen ahora varias formas de bases de datos que pueden almacenarse en un archivo, que pueden accesarse de otras formas, etc. Existen 6 ``sabores'' de DBs con las que puede que nos topemos seguido: Microsoft Access, LibreOffice Base, Microsoft SQL Server, MySQL, PostgreSQL y SQLite. Para nuestro caso en particular que solemos llevar y traer datos, que no tenemos conecciones del todo estables de internet, que buscamos universalidad evitando software caro y que deseamos algo preque\~no, r\'apido de usar y que no involucre tener que montar todo un sistema para ello, la portabilidad, el costo y la sencillez son importantes. Por eso haremos uso de SQLite.
\newpage
\subsection{Seleccionando Datos}
Para explicar c\'omo funcionan las bases de datos se comienza generalmente por el final. Lo primero en describirse es c\'omo se ven los datos ya ingresados en una y luego se pasa a explicar c\'omo se crean, eliminan, c\'omo se le agregan datos o se le quitan, etc. Para entender el c\'omo y el por qu\'e de esto, se propone una analog\'ia:\\

Cuando vamos a un laboratorio, generalmente hay una persona que es la encargada de los reactivos y el equipo (o en cargado de bodega). A esta persona debemos decirle lo que necesitamos para que nos lo prepare y lo tenga listo a la hora de realizar una pr\'actica o un procedimiento. Si repasamos detenidamente lo que tenemos qu\'e hacer para ello, hallaremos las similitudes con una DB.
\begin{enumerate}
\item Llegamos al laboratorio.
\item Nos presentamos con el encargado del laboratorio.
\item Le pedimos los listados de equipo o reactivos si no sabemos cu\'ales son todav\'ia.
\item Seleccionamos lo que deseamos de los listados.
\item Recibimos el equipo y los reactivos como el resultado de nuestra consulta.
\end{enumerate}
En el caso de una DB, los pasos para obtener informaci\'on son muy similares.
\begin{enumerate}
\item Localizamos la base de datos.
\item Iniciamos con el administrador.
\item Solicitamos las tablas en la base de datos, si no las conocemos todav\'ia.
\item Seleccionamos los datos que deseamos de una tabla.
\item El administrador nos despliega el resultado de nuestra consulta.
\end{enumerate}
Como podemos ver, los pasos son similares. Otra cosa que debemos tomar en cuenta es que a nosotros no se nos dejaba usar reactivos o equipo (m\'as adelante pedir reactivos o equipo) hasta que ya hubi\'eramos pasado algunos cursos, tenido un poco de experiencia y estado concientes de lo que est\'abamos haciendo. Tambi\'en debemos recordar que aunque ya se nos deje solicitar estas cosas, siempre lo debemos hacer a trav\'es del encargado del laboratorio o bodega. Con esto en mente ya procederemos a ir paso a paso aprendiendo c\'omo se usa una DB.\\

Para comenzar vamos a vamos a abrir una l\'inea de comando y en ella iremos hasta nuestro directorio de documentos. All\'i ingresaremos el comando \inlinecode{sqlite3 monitoreo.db} Aqu\'i vamos a ver algunas l\'ineas que describen la versi\'on de SQLite que tenemos y c\'omo obtener ayuda. Considerando que ya estamos en una DB, piensa por un momento: qu\'e es lo que nos gustar\'ia saber de esta base de datos?\\

Si ``el contenido'' fue lo primero que apareci\'o en nuestra mente, nos estamos adelantando un poco y estamos perdiendo la noci\'on de la idea de una base de datos. Por qu\'e ser\'a que ver \emph{todo} el contenido es una mala idea? (Pensemos en bases de datos grandes.) Antes de apresurarnos a ver qu\'e hay dentro de la DB, debemos entender c\'omo se divide; qu\'e listas de reactivos o equipos hay. Para ello vamos a ingresar el comando \inlinecode{.tables} Qu\'e te mostr\'o el administrador? Qu\'e crees que son esos nombres? Pi\'ensalo y disc\'utelo un momento.

Vamos a ver el contenido de cada una de las tablas en la base de datos, pero antes, vamos a configurar a SQLite para que los resultados nos sean f\'aciles de interpretar. Para ello vamos a ingresar los siguientes dos comandos:

\begin{Code}
.headers ON\\
.mode columns
\end{Code}

Estos nos permitir\'an visualizar los datos como columnas ordenadas y con sus respectivos encabezados. Ahora s\'i procederemos a ver qu\'e hay en las tablas.

\subsubsection{Una Consulta Sencilla}
La base de datos con la que estamos trabajando contiene datos \emph{falsos} del laboratorio de Monitoreo del Aire. Despu\'es de haber visto qu\'e tablas hab\'ia en ellos y sabiendo c\'omo es que funcionan los laboratorios, es seguro pensar que las tablas de los lugares y las personas van a ser m\'as peque\~nas que las de los muestreos. Por ello, para nuestra primera consulta vamos a ver qui\'enes han hecho an\'alisis en el laboratorio de Monitoreo del Aire.\\

Comencemos! La idea ser\'a seleccionar toda la tabla para conocer qu\'e \emph{campos} contiene esta, y adem\'as, qu\'e \emph{entradas} hay almacenadas. Recapitulando: vamos a seleccionar toda la informaci\'on de la tabla de \textbf{Personas}. El comando para esto es el siguiente: \inlinecode{SELECT * FROM Personas;} Analicemos un momento el comando e intentemos entender qu\'e es lo que hace cada parte. Adem\'as, anotemos los encabezados de cada columna; nos van a servir despu\'es.\\

Hay dos partes que merecen atenci\'on de nuestra primera consulta. La primera, y muy importante, es que \textbf{toda} consulta hecha en SQL debe terminar con un punto y coma. La segunda cosa a notar es el asterisco. Como ya hab\'iamos visto ayer en la l\'inea de comando, el asterisco se utiliza como un comod\'in; un caracter que puede representar lo que sea. En este caso eso nos permite extraer toda la informaci\'on de la tabla. Pero, qu\'e puede usarse si no es un comod\'in? Para ello vamos a volver a hacer la consulta, haciendo una variaci\'on: \inlinecode{SELECT nombre FROM Personas;} Observa qu\'e fue lo que pas\'o e intenta explicar por qu\'e ocurri\'o el cambio.\\

Ahora que ya vimos c\'omo realizar consultas de un \emph{campo} en particular, vamos a intentar realizar una con varios campos. Para ello vamos a intentar incluir varios campos dentro de la consulta y sin un orden en particular. \inlinecode{SELECT apellido, pid, nombre FROM Personas;} Como vemos, podemos accesar los campos que querramos y en el orden que querramos. Esto nos ser\'a \'util cuando solo necesitemos de alguna informaci\'on de la base de datos, y no todo el contenido de las tablas.\\

Como ejercicio r\'apido, revisa el contenido de las tablas \textbf{Lugares} y \textbf{Muestreo}; nos va a servir despu\'es. Ten cuidado con la tabla \textbf{Muestreo}: ser\'an bastantes resultados. Toma nota de los campos de cada una.\\

Hemos visto c\'omo controlar los campos en cada tabla. Despu\'es vamos a ver c\'omo visualizar solo algunas entradas dependiendo de alguna condici\'on. Por ahora, es importante que sepamos que casi siempre existe alg\'un n\'umero, c\'odigo o identificador que servir\'a para representar a cada entrada. No existen dos identificadores iguales, y generalmente a este campo se le llama \emph{llave primaria}. En los ejemplos anteriores, este ha sido el campo llamado \inlinecode{pid}.

\subsubsection{Ordenando y Filtrando \emph{donde} se cumpla una Condici\'on}
Una de las tareas complicadas al trabajar con hojas de c\'alculo (como en Microsoft Excel) es el filtrar los datos para poder visualizar alguna tendencia o patr\'on en particular. Utilizando SQL, esto se vuelve una tarea sencilla. Es com\'un, por ejemplo, que necesitemos ver la cantidad de alg\'un compuesto en un lugar en particular a lo largo del tiempo, pero en la base de datos tenemos todo junto. Para ello solo tenemos que aprender a filtrar los resultados que est\'abamos obteniendo antes.\\

Vamos a consultar por todas las personas con apellido `Garc\'ia' que se encuentren en la tabla \textbf{Personas}. Refrescando un poco, la consulta que ten\'iamos antes se ve\'ia as\'i: \inlinecode{SELECT * FROM Personas;} Ahora debemos seleccionar \emph{todas} las entradas de la tabla \textbf{Personas}, en \emph{donde} el apellido sea igual a Garc\'ia. Para ello, la consulta se ver\'a as\'i: \inlinecode{SELECT * FROM Personas WHERE apellido='Garcia';}\\

El resultado se explica por s\'i solo. Intentemos ahora consultar a la base de datos, a modo de que se distinga si hay entradas con un campo repetido y eliminar los duplicados. Para ello, intentemos con la siguiente consulta: \inlinecode{SELECT DISTINCT apellido FROM Personas;} El resultado nos revela solo las entradas \emph{distintas}! Eliminar duplicados fue f\'acil. Intentemos ordenar los resultados bas\'andonos en el nombre (por orden alfab\'etico, claro). La consulta ha de verse as\'i: \inlinecode{SELECT * FROM Personas ORDER BY nombre;} Observemos los resultados y notemos c\'omo aparece la columna de nombres y la de identificadores. Ahora, para terminar con la parte de ordenado, vamos a ordenar los apellidos de esta tabla de forma descendente: \inlinecode{SELECT * FROM Personas ORDER BY apellido DESC;}\\

Eso fue sencillo y nos dio los resultados esperados. Vamos a intentar algo un poco m\'as complicado. El tr\'ebol en la ciudad de guatemala tiene las coordenadas: $14.613309^o N$ y $90.535149^o O$. Esto se traduce en las cifras: $14.613309$ y $-90.535149$. Cuando la longitud es mayor, nos movemos m\'as al este (a la derecha en el mapa). Cuando la latitud es mayor, nos movemos m\'as al norte (hacia arriba en el mapa). Vamos a intentar hallar todos aquellos lugares en el extremo superior derecho con respecto al tr\'ebol (NE). Para ello necesitmos que la longitud y la latitud sean mayores a las coordenadas el tr\'ebol. En particular, queremos los nombres de los lugares. Intentemos hacer esto con una nueva consulta:
\inlinecode{SELECT nombre FROM Lugares WHERE (longitud>-90.535149) AND (latitud>14.613309);}\\

Esto nos debi\'o haber mostrado solo un resultado: MUSAC. Tengamos cuidado con los signos de mayor y menor! Ahora, como ejercicio, intentemos consultar por las otras 3 direcciones: NO, SO, SE. Para terminar con esta secci\'on, vamos a realizar una consulta sencilla de la tabla \textbf{Lugares}. Vamos a extraer todos los nombres de lugares que comiencen con \emph{i}. Para ello vamos a hacer la siguiente consulta:\\ \inlinecode{SELECT nombre FROM Lugares WHERE (nombre LIKE 'I\%');}\\

Con esto \'ultimo ya podemos hallar cosas semejantes. Si nos damos cuenta atentamente, el comod\'in en este caso no es el asterisco \inlinecode{*} como normalmente hab\'ia sido, sino que ahora es el signo de porcentaje \inlinecode{\%}

\subsubsection{Juntando Tablas}
Esta es una de las partes m\'as importantes de las bases de datos y es lo que les da \textbf{toda} la magia. Por ahora solo hab\'iamos notado que en la tabla de \textbf{Muestreo} ten\'iamos un campo para personas y uno para lugares, pero estaban llenos de n\'umeros. Si hab\'iamos puesto atenci\'on a los detalles, nos dimos cuenta de que esos n\'umeros son realmente los identificadores \emph{pid} y \emph{lid} de las tablas \textbf{Personas} y \textbf{Lugares} respectivamente. Y es que de aqu\'i es de donde viene el nombre de las bases de datos relacionales: relacionan los datos entre tablas para no tener que guardar cierto dato grande repetidas veces en una sola tabla. Y ahora vamos a ver c\'omo es que estas se relacionan realmente.\\

Vamos a intentar mostrar a las personas que trabajaron en an\'alisis en el laboratorio de Monitoreo del Aire durante el mes de enero del a\~no 2013. Para ello deberemos filtrar por fecha, y juntar a la tabla de \textbf{Muestreo} con la de \textbf{Personas}. Hagamos la consulta:

\begin{Code}
SELECT Muestreo.mid, Personas.nombre, Muestreo.fecha FROM Muestreo JOIN Personas ON Muestreo.persona=Personas.pid WHERE (Muestreo.fecha>='2013-01-01') AND (Muestreo.fecha<='2013-01-31');
\end{Code}

La consulta se ve algo monstruosa, pero la verdad solo son muchos pedacitos unidos en una gran l\'inea. Vamos paso a paso: Algo nuevo es que estamos llamando a cada campo con su nombre y apellido. Ya no estamos solo pidiendo \inlinecode{fecha} por ejemplo, sino que estamos pidiendo \inlinecode{Muestreo.fecha} Esto se debe a que estamos trabajando con \emph{dos} tablas en vez de una y debemos ser claros con los campos de cada una (habr\'an veces en donde dos tablas tienen campos con los mismos nombres y la forma de diferenciarlos es con el nombre de la tabla). Luego, utilizamos una nueva palabra clave: \inlinecode{JOIN} Esta es la que va a traer la \emph{otra} tabla, en este caso la de \textbf{Personas} y la deja a disposici\'on nuestra. Finalmente vemos que hay una \'ultima palabrita nueva en nuestra consulta: \inlinecode{ON} Esta se\~nala en d\'onde estamos juntando las dos tablas, o en otras palabras, en d\'onde existe la relaci\'on entre las dos.\\

Recapitulando, la consulta que hicimos dice as\'i: seleccionar el identificador de la tabla de Muestreo, el nombre de la tabla de Personas y la fecha de la tabla de Muestreo desde la tabla de Muestreo unida a la tabla de Personas entre el campo personas de Muestreo y el identificador de Personas, cuando la fecha sea mayor o igual al primero de enero del 2013 y menor o igual al 30 de enero del 2013. Ahora nos parece que verla en SQL es m\'as f\'acil. Es de agradecer que generalmente esto solo se programa en un lenguaje de programaci\'on \emph{una vez} y luego ya no se tiene que volver a ver. Sin embargo, la idea se mantiene. Y lo importante es que las bases de datos relacionales pueden crear este tipo de relaciones entre tablas. Ahora pasaremos a ver qu\'e se puede hacer con los resultados que hemos estado obteniendo de tantas maneras.

\subsection{Operaciones Matem\'aticas}
Adem\'as de observar datos ordenados de diferentes maneras y filtrados, muchas veces queremos extraer informaci\'on colectiva de todos los datos o ver los datos de diferente manera. Para esto nos hace falta poder realizar operaciones a los datos y as\'i obtener resultados diferentes. Para comenzar debemos de tomar en cuenta ciertas cosas. Las operaciones b\'asicas son suma, resta multiplicaci\'on, divisi\'on y m\'odulo. Los signos que las representan en SQL son \inlinecode{+}, \inlinecode{-}, \inlinecode{*}, \inlinecode{/} y \inlinecode{\%}\\

Por si nunca hab\'iamos escuchado de la operaci\'on m\'odulo, la aclaramos r\'apidamente: es la operaci\'on que nos devuelve el residuo de una divisi\'on (e.g. \inlinecode{5\%2 = 1}, \inlinecode{7\%5 = 2} y \inlinecode{7\%4 = 3}). A pesar de que ahorita no le veamos mucho uso, esta operaci\'on hace de la programaci\'on algo mucho m\'as c\'omodo en muchos casos.

\subsubsection{Alterando el Resultado}
Vamos a trabajar finalmente con la tabla \textbf{Muestreo}. En ella hay muchos datos (falsos) sobre mediciones de varios gases y material particulado en el aire. Resulta que los datos de PM10 est\'an dados en gramos y para un estudio en Estados Unidos los necesitan en onzas. Tambi\'en necesitan que estos datos sean solo los del a\~no 2012. Para ello necesitamos pasar todos los datos de PM10 a onzas y filtrar. C\'omo hacemos eso? Pues es sencillo. El factor de conversi\'on es el siguiente: $1g = 0.035274 oz$, as\'i que lo que debemos hacer es multiplicar todos nuestros datos de PM10 por ese factor. Intent\'emoslo.\\

Lo primero que debemos pensar es en hacer una consulta a la tabla de \textbf{Muestreo}. De ella vamos a tomar solo los datos de $CO_2$, estos los vamos a multiplicar por nuestro factor y luego vamos a filtrar las fechas. Veamos la consulta: \inlinecode{SELECT PM10 * 0.035274, fecha FROM Muestreo WHERE (fecha>'2012-01-01') AND (fecha<'2012-12-31');} Los resultados son exactamente lo que busc\'abamos! Todos los resultados transformados a otra unidad. Y as\'i se podr\'ia hacer con cualquier columna o cualquier operaci\'on. Todos nuestros datos los podemos representar de maneras distintas. Pero, ser\'a que podemos utilizar esto tambi\'en dentro de las condiciones?\\

Como un ejercicio peque\~no, intenta descifrar qu\'e es lo que hace las siguientes consultas:
\begin{Code}
SELECT * FROM Personas WHERE pid\%2=0;\\
SELECT round(pH,4), fecha FROM Muestreo WHERE round(pH,1)>6.5;
\end{Code}

\subsubsection{Obteniendo Descriptores}
Cuando ya logramos manipular nuestros datos, solo nos queda una cosa por hacer. Comenzar a calcular valores nuevos a partir de ellos. En estad\'istica, estos se llaman descriptores. SQLite permite calcular algunos descriptores sencillos, como los que vamos a ver a continuaci\'on. Para hacer an\'alisis m\'as extensos de la informaci\'on ya se utilizan Mapeos Objeto-Relacional (u ORMs por sus siglas en ingl\'es) y paquetes estad\'isticos, los cuales tocaremos brevemente m\'as adelante. Por ahora, comencemos con lo b\'asico.\\

Los descriptores que podemos calcular con facilidad en SQLite son la media, el m\'inimo, el m\'aximo, contar las entradas y la suma o total de todas. Veremos que una vez aprendemos una, las dem\'as son sencillas. Existen algunos m\'etodos sucios de calcular la varianza haciendo uso de estas funciones y operaciones matem\'aticas, pero siempre es m\'as conveniente utilizar un ORM en vez de SQL para esto.\\

De los datos de $CO_2$ en la tabla de \textbf{Muestreo} vamos a calcular todos estos descriptores para el a\~no 2013. Para ello vamos a realizar las siguientes consultas:

\begin{Code}
SELECT min(CO2) FROM Muestreo WHERE (fecha>='2013-01-01') AND (fecha<='2013-12-31');\\
SELECT max(CO2) FROM Muestreo WHERE (fecha>='2013-01-01') AND (fecha<='2013-12-31');\\
SELECT count(CO2) FROM Muestreo WHERE (fecha>='2013-01-01') AND (fecha<='2013-12-31');\\
SELECT avg(CO2) FROM Muestreo WHERE (fecha>='2013-01-01') AND (fecha<='2013-12-31');\\
SELECT sum(CO2) FROM Muestreo WHERE (fecha>='2013-01-01') AND (fecha<='2013-12-31');
\end{Code}

\subsection{\'Ultimas Consultas}
El \'ultimo ejercicio que haremos con respecto a lo que hemos visto hasta ahora ser\'a una extra\~na combinaci\'on de todo. La idea ser\'a obtener como resultado el promedio de los datos de $SO_2$ del INCAP para todo el a\~no 2012. Y luego, siguiendo la misma idea, desplegar los datos de $NO_2$, la fecha y los analistas para MUSAC en el a\~no 2013. Antes de comenzar a probar, pensemos un momento lo que queremos hacer y propongamos la consulta sin revisar c\'omo se hace.\\

\subsubsection{Primera Consulta Final}

\noindent Queremos una consulta de los muestreos: \inlinecode{SELECT * FROM Muestreo;}\\
En particular, queremos el promedio de los datos de $SO_2$: \inlinecode{SELECT avg(SO2) FROM Muestreo;}\\
Pero los deseamos solo de un lugar en particular y ese lugar viene de otra tabla:
\begin{Code}
SELECT avg(Muestreo.SO2) FROM Muestreo JOIN Lugares ON Muestreo.lugar=Lugares.lid;
\end{Code}
En particular, lo queremos del INCAP:
\begin{Code}
SELECT avg(Muestreo.SO2) FROM Muestreo JOIN Lugares ON Muestreo.lugar=Lugares.lid WHERE (Lugares.nombre='INCAP');
\end{Code}
Y el resultado lo deseamos entre el primero de enero del 2012 y el 31 de diciembre del mismo a\~no:
\begin{Code}
SELECT avg(Muestreo.SO2) FROM Muestreo JOIN Lugares ON Muestreo.lugar=Lugares.lid WHERE (Lugares.nombre='INCAP') AND (Muestreo.fecha>='2012-01-01') AND (Muestreo.fecha<='2012-12-31');
\end{Code}

Y as\'i logramos el resultado de la primera consulta que quer\'iamos realizar. Ahora intent\'emoslo con la segunda.\\

\subsubsection{Segunda Consulta Final}

\noindent Queremos una consulta de los muestreos nuevamente: \inlinecode{SELECT * FROM Muestreo;}\\
En particular, queremos los datos de $NO_2$ y la fecha: \inlinecode{SELECT NO2, fecha FROM Muestreo;}\\
Pero los deseamos solo de un lugar en particular y ese lugar viene de otra tabla:
\begin{Code}
SELECT Muestreo.NO2, Muestreo.fecha FROM Muestreo JOIN Lugares ON Muestreo.lugar=Lugares.lid;
\end{Code}
En particular, lo queremos del MUSAC:
\begin{Code}
SELECT Muestreo.NO2, Muestreo.fecha FROM Muestreo JOIN Lugares ON Muestreo.lugar=Lugares.lid WHERE (Lugares.nombre='MUSAC');
\end{Code}
Tambi\'en deseamos los nombres de los analistas, y para ello necesitamos a la tercera tabla:
\begin{Code}
SELECT Muestreo.NO2, Muestreo.fecha FROM Muestreo JOIN Lugares ON Muestreo.lugar=Lugares.lid JOIN Personas ON Muestreo.persona=Personas.pid WHERE (Lugares.nombre='MUSAC');
\end{Code}
Los nombres deben de aparecer como resultado de la consulta, as\'i que debemos incluirlos:
\begin{Code}
SELECT Muestreo.NO2, Muestreo.fecha, Personas.nombre, Personas.apellido FROM Muestreo JOIN Lugares ON Muestreo.lugar=Lugares.lid JOIN Personas ON Muestreo.persona=Personas.pid WHERE (Lugares.nombre='MUSAC');
\end{Code}
Y el resultado lo deseamos entre el primero de enero del 2013 y el 31 de diciembre del mismo a\~no:
\begin{Code}
SELECT Muestreo.NO2, Muestreo.fecha, Personas.nombre, Personas.apellido FROM Muestreo JOIN Lugares ON Muestreo.lugar=Lugares.lid JOIN Personas ON Muestreo.persona=Personas.pid WHERE (Lugares.nombre='MUSAC') AND (Muestreo.fecha>='2013-01-01') AND (Muestreo.fecha<='2013-12-31');
\end{Code}
Por est\'etica decidimos incluir el lugar como una de los columnas a desplegarse y ordenar los resultados por apellidos de manera descendente.
\begin{Code}
SELECT Lugares.nombre, Muestreo.NO2, Muestreo.fecha, Personas.nombre, Personas.apellido FROM Muestreo JOIN Lugares ON Muestreo.lugar=Lugares.lid JOIN Personas ON Muestreo.persona=Personas.pid WHERE (Lugares.nombre='MUSAC') AND (Muestreo.fecha>='2013-01-01') AND (Muestreo.fecha<='2013-12-31') ORDER BY Personas.apellido DESC;
\end{Code}

Como siempre, nuestra consulta al final de cuentas se ve algo monstruosa, pero logr\'o lo que dese\'abamos hacer. Ahora que ya tenemos una idea sobre c\'omo trabajar con SQL, vamos a pasar a una parte que requiere de m\'as seriedad y delicadeza de nosotros.

\subsection{Creando, Actualizando y Eliminando}
En este segmento vamos a pasar a tomar m\'as responsabilidad de nuestras acciones y vamos a ir con el encargado de bodega a sacar y meter el equipo y los reactivos que necesitamos. Incluso vamos a ayudarle a mover muebles de la bodega! La idea ahora ser\'a llegar al principio: c\'omo crear una base de datos y agregarle datos. Esta parte, contrario a lo que cualquiera esperar\'ia, es bastante sencilla, pero mucho m\'as peligrosa. Si llegamos a agregar algo que no es real o a eliminar un dato, no hay vuelta atr\'as: hicimos algo mal y corregirlo cuesta.

\subsubsection{Bases de Datos}
Crear una base de datos en SQLite no es nada complicado. Hay otras DBs como MySQL o PostgreSQL que requieren que entremos al administrador de DB antes de crearla en s\'i. En el caso de SQLite, lo \'unico que debemos hacer es lo mismo que hacemos para abrirla. En una l\'inea de comando linux escribimos \inlinecode{sqlite3 nombre\_de\_mi\_nueva.db} Y ya, con eso estamos dentro de nuestra nueva base de datos. Por supuesto, debemos utilizar nombres significativos en nuestros archivos.\\

Para eliminar una base de datos, la operaci\'on es a\'un m\'as f\'acil. Puesto que una base de datos en SQLite es un archivo, solo necesitamos eliminarlo; eso es todo. Sin embargo, recordemos que borrar datos es algo \textbf{MUY} peligroso. Solo se debe de hacer si esos datos no nos van a servir a nosotros ni a nadie nunca.

\subsubsection{Tablas}
Crear una tabla ya es un proceso un poco m\'as complicado. Para ello hay una serie de palabras y conceptos que debemos saber. De hecho, crear una tabla ya es algo que se hace con SQL. Para realizar este ejercicio, vamos a replicar la base de datos con la que est\'abamos trabajando. Para eso vamos a crear una nueva DB que se llamar\'a \emph{mi\_monitoreo.db} Una vez estemos adentro, la vamos a configurar con \inlinecode{.headers ON} y \inlinecode{.mode columns} Ahora procederemos a crear la primera tabla.

\begin{Code}
CREATE TABLE Personas (\\
\hspace*{5mm}pid INTEGER NOT NULL,\\
\hspace*{5mm}nombre VARCHAR(15),\\
\hspace*{5mm}apellido VARCHAR(15),\\
\hspace*{5mm}PRIMARY KEY(pid)\\
);
\end{Code}

La parte de crear la tabla llamada \textbf{Personas} es f\'acil de entender. Lo que no es tan sencillo son las l\'ineas que siguen. Pero qu\'e dicen realmente? En este caso, cada l\'inea es un campo de la nueva tabla (excepto por la \'ultima l\'inea, pero ya llegaremos a ella). En cada l\'inea necesitamos especificar qu\'e tipo de dato es el que vamos a almacenar. Por ello, para \emph{pid} decimos que almacenar\'a enteros \inlinecode{INTEGER}, y que jam\'as puede estar vac\'ia \inlinecode{NOT NULL} El campo \emph{nombre} almacenar\'a caracteres de largo variable \inlinecode{VARCHAR} hasta un m\'aximo de 15 caracteres \inlinecode{VARCHAR(15)} Lo mismo suceder\'a con el campo \emph{apellido}. Finalmente tenemos una l\'inea en la que especificamos que \emph{pid} ser\'a nuestra llave primaria \inlinecode{PRIMARY KEY(pid)}: el identificador del que tanto habl\'abamos antes que exist\'ia en cada tabla. Veamos otro caso!

\begin{Code}
CREATE TABLE Lugares (\\
\hspace*{5mm}lid INTEGER NOT NULL,\\
\hspace*{5mm}nombre TEXT,\\
\hspace*{5mm}latitud REAL,\\
\hspace*{5mm}longitud REAL,\\
\hspace*{5mm}PRIMARY KEY(lid)\\
);
\end{Code}

Las diferencias no son muchas. Vale la pena mencionar que con \inlinecode{VARCHAR} le podemos colocar un l\'imite a la cantidad de caracteres a almacenarse para que la base de datos no ocupe espacio de m\'as. \inlinecode{TEXT} por otra parte, no pone l\'imite y a este se le puede ingresar cantidades muy grandes de texto. El tipo de dato \inlinecode{REAL} especifica que los datos en ese campo son n\'umeros reales. Y fuera de eso, no hay muchas diferencias con la tabla anterior. Intentemos crear la \'ultima tabla.\\

\begin{Code}
CREATE TABLE Muestreo (\\
\hspace*{5mm}mid INTEGER NOT NULL,\\
\hspace*{5mm}perona INTEGER NOT NULL,\\
\hspace*{5mm}lugar INTEGER NOT NULL,\\
\hspace*{5mm}CO2 REAL,\\
\hspace*{5mm}NO2 REAL,\\
\hspace*{5mm}SO2 REAL,\\
\hspace*{5mm}PM10 REAL,\\
\hspace*{5mm}[PM2.5] REAL,\\
\hspace*{5mm}pH REAL,\\
\hspace*{5mm}fecha DATE,\\
\hspace*{5mm}PRIMARY KEY(mid),\\
\hspace*{5mm}FOREIGN KEY(persona) REFERENCES Personas(pid),\\
\hspace*{5mm}FOREIGN KEY(lugar) REFERENCES Lugares(lid)\\
);
\end{Code}

Aqu\'i nos damos cuenta de que hay un campo nuevo: \inlinecode{DATE} Este almacena fechas nada m\'as. Hay otro formato similar que puede almacenar fechas y horas. Ser\'ia un buen ejercicio averiguar cu\'al es. Por el momento, nos interesa ver qu\'e es lo que agregamos al final. Esas \'ultimas dos l\'ineas son las que indican que un campo de nuestra tabla debe de referirse al campo de \emph{otra} tabla. Esto tiene varias ventajas realmente. En la tabla de \textbf{Muestreo}, los campos \emph{persona} o \emph{lugar} no van a aceptar ning\'un valor que no exista en las otras tablas (\textbf{Personas} y \textbf{Lugares}). Adem\'as, no podremos eliminar una entrada de estas \'ultimas dos tablas, si existe alguna entrada en \textbf{Muestreo} que se refiera a ellas. Esto es una gran ayuda!\\

Ahora mencionaremos nada m\'as c\'omo es que las tablas se pueden eliminar. Esto \'ultimo es bastante f\'acil en SQL. El comando para esto es \inlinecode{DROP TABLE Muestreo;} A veces la creaci\'on o eliminaci\'on de una tabla toma tiempo; seamos pacientes si as\'i es el caso. Por ahora no eliminemos ninguna de nuestras dos nuevas tablas; nos servir\'an. Pero para proseguir, debemos ingresar algunos datos en ellas.

\subsubsection{Entradas}
Insertar nuevas entradas a una tabla es una tarea que, como todo en SQL, no es tan complicado. Sin embargo, se requiere de escribir bastante. Para insertar una nueva entrada, debemos especificar en qu\'e tabla vamos a ingresar la entrada, qu\'e columnas tiene, y qu\'e valores vamos a ingresar. Agreguemos algunas entradas a la tabla de \textbf{Personas}.

\begin{Code}
INSERT INTO Personas(pid, nombre, apellido) VALUES(NULL, 'Alvaro', 'Garcia');\\
INSERT INTO Personas(pid, nombre, apellido) VALUES(NULL, 'Eduardo', 'Saquilmer');\\
INSERT INTO Personas(pid, nombre, apellido) VALUES(NULL, 'Francisco', 'Garcia');\\
INSERT INTO Personas(pid, nombre, apellido) VALUES(NULL, 'Elisandra', 'Hernandez');
\end{Code}

Aqu\'i hay algo peculiar. Notamos que para \emph{pid} estamos ingresando el valor \inlinecode{NULL}. Si recordamos bien cuando creamos la tabla, especificamos que ese campo \textbf{no} pod\'ia estar vac\'io; no pod\'ia ser \inlinecode{NULL} Entonces qu\'e pas\'o? Como especificamos que \emph{pid} es una llave primaria, SQLite inserta un n\'umero en vez de dejar el campo vac\'io. Como tambi\'en especificamos que ese campo solo pod\'ia almacenar n\'umeros enteros, SQLite comienza numerando desde 1 en adelante. A cada nueva entrada le toca el n\'umero siguiente, a menos de que seamos nosotros los que asignemos un n\'umero en particular. Eso nos lleva a otra cosa que se puede hacer con las entradas.\\

Despu\'es de ingresar toda la informaci\'on en la tabla de \textbf{Lugares}, nos damos cuenta de que nos equivocamos en algo: ingresamos INCAP una segunda vez, en vez de ingresar MUSAC. Cl\'asico error de estar ingresando datos solo copiando y pegando la misma l\'inea y haci\'endole cambios cada vez. Ahora la pregunta es: qu\'e hacemos?

\begin{Code}
INSERT INTO Lugares(lid, nombre, longitud, latitud) VALUES(1,'INSIVUMEH',-90.532677,14.487356);\\
INSERT INTO Lugares(lid, nombre, longitud, latitud) VALUES(2,'T10',-90.554700,14.585181);\\
INSERT INTO Lugares(lid, nombre, longitud, latitud) VALUES(3,'EFPEM',-90.545535,14.588231);\\
INSERT INTO Lugares(lid, nombre, longitud, latitud) VALUES(4,'San Juan',-90.547528,14.622473);\\
INSERT INTO Lugares(lid, nombre, longitud, latitud) VALUES(5,'INCAP',-90.539983,14.616133);\\
INSERT INTO Lugares(lid, nombre, longitud, latitud) VALUES(6,'INCAP',-90.510983,14.638987);
\end{Code}

Para enmendar este tipo de errores, o para hacer cambios puntuales en una entrada en particular, existe una consulta de actualizaci\'on de datos. Vamos a actualizar de una tabla, el valor de un campo establecido, en donde se cumpla alguna condici\'on. Veamos esta consulta para entender mejor la situaci\'on:

\begin{Code}
UPDATE Lugares SET nombre='MUSAC' WHERE lid=6;
\end{Code}

De esta forma corregimos el error que hab\'iamos hecho. Si no ponemos una condici\'on, se le pondr\'a de nombre MUSAC a todas las entradas. La condici\'on es la que especifica en qu\'e entrada se debe de hacer el cambio realmente. Finalmente, qu\'e hubiera pasado si en vez de habernos equivocado en un nombre, hubieramos ingresado el mismo dato dos veces? La respuesta es evidente: borrar una de las dos entradas.\\

Supongamos que de casualidad agregamos otra vez la informaci\'on del INCAP:\\ \inlinecode{INSERT INTO Lugares(lid, nombre, longitud, latitud) VALUES(NULL,'INCAP',-90.510983,14.638987);}\\
Lo que nos queda ahora es eliminar la \'ultima, para ello debemos saber seleccionar esa entrada \'unicamente. Pensemos por un momento, c\'omo seleccionamos solamente esa entrada? La \'unica alternativa que nos queda es utilizar el identificador. Por qu\'e? Porque es el \'unico que declaramos como llave principal. Eso significa que es \'unico en toda la tabla! Por eso dise\~namos nuestra consulta de la siguiente manera:

\begin{Code}
SELECT * FROM Lugares WHERE lid=7;
\end{Code}

Perfecto! La podemos mostrar de manera aislada. Pero esto de qu\'e nos sirve? Pues que este es el primer paso para eliminar una entrada: saber c\'omo hallarla y aislarla. Eliminarla solo requiere de un peque\~no cambio en la consulta que acabamos de hacer: \inlinecode{SELECT *} lo reemplazamos con \inlinecode{DELETE}. Entonces la consulta se ve de la siguiente manera:

\begin{Code}
DELETE FROM Lugares WHERE lid=7;
\end{Code}

\noindent Y as\'i de sencillo se puede eliminar una entrada.

\subsubsection{Construyendo y Exportando una Base de Datos}
Si seguimos las indicaciones del taller hasta ahora, tenemos una base de datos nueva con dos tablas: la de \textbf{Personas} y la de \textbf{Lugares}. La de \textbf{Muestreo} la hab\'iamos creado, pero la eliminamos. Por otra parte, todas estas consultas que hemos hecho las hemos tenido que ir ingresando una a una para acceder a los datos y editarlos. No ser\'ia m\'as eficiente que nuestro ordenador pudiera solo leer todas las instrucciones de un solo y armar la base de datos o realizar una consulta complicada? Pues s\'i la hay! Vamos a crear la tabla de \textbf{Muestreo} y llenarla con todos los datos que esta lleva sin escribir m\'as que una l\'inea. En nuestro directorio de documentos se halla un archivo de texto llamado \emph{monitoreo.txt}. Abr\'amoslo por un momento y, sin alterar el contenido, entendamos lo que hay en \'el.\\

Posteriormente, despu\'es de entender eso, vamos a volver a nuestra l\'inea de comando con nuestra base de datos nueva y en ella vamos a escribir \inlinecode{.read monitoreo.txt} Esto, en SQLite, lee todo el contenido del archivo y lo ejecuta. Puede que se tarde un momento, pero al final, la tabla de \textbf{Muestreo} no solo estar\'a creada, sino llena con toda la informaci\'on tambi\'en. Esto resulta m\'as c\'omodo, especialmente cuando tenemos datos en hojas de c\'alculo (Miscrosoft Excel) y las deseamos pasar a una base de datos. El procedimiento para hacerlo es similar. Esto es otra cosa que ser\'ia conveniente investigar despu\'es.\\

Finalmente vamos a hacer el mismo procedimiento que acabamos de hacer, pero al rev\'es. Vamos extraer las instrucciones de creaci\'on y llenado de una base de datos. Esto resulta \'util cuando no estamos trabajando con una base de datos SQLite (que es port\'atil). Adem\'as, tambi\'en resulta \'util si se desea migrar de una base de datos a otra (e.g. MySQL a SQLite), el SQL suele ser el mismo o tener pocas variaciones. Veamos c\'omo se hace.\\

Hacer una copia de seguridad de las instrucciones de la base de datos es algo que, si bien se puede hacer desde dentro de la DB, es m\'as sencillo hacerlo desde afuera de ella en el caso de SQLite. Lo que debemos hacer es colocarnos en el directorio con la DB e ingresar: \inlinecode{sqlite3 mi\_base\_de\_datos.db '.dump' >\ mi\_dump.sql} El resultado ser\'a un nuevo archivo en nuestra carpeta con todas las instrucciones para ensamblar y llenar una base de datos.\\

La alternativa a hacer esto es hacerlo desde dentro de la DB. Para ello vamos a ingresar a la base de datos mediante: \inlinecode{sqlite3 monitoreo.db} y luego vamos a decirle 2 cosas al administrador: que queremos que los resultados los guarde en un archivo \inlinecode{.output mi\_dump2.sql} y que deseamos que ese archivo se llene con todas las instrucciones de creaci\'on de la base de datos \inlinecode{.dump} Eso es todo.\\

Antes de terminar con esta secci\'on, es recomendable que abramos uno de los archivos que acabamos de crear y los veamos completamente. Vamos a notar que las primeras 2 l\'ineas y la \'ultima no son algo que nosotros entendamos. Esto es solo algo que agreg\'o el administrador al hacer el \emph{dump}. Borremos esas l\'ineas y nuestro archivo queda listo para armar una base de datos en cualquier momento.

\subsection{Biblioteca y Toxicidades}
La mayor\'ia de bibliotecas en el mundo se manejan ya con ficheros electr\'onicos. Utilizan el c\'odigo ISBN de los libros como identificador y adem\'as permiten listar la informaci\'on de cada libro, adem\'as de su disponibilidad, en l\'inea. Esto es una clara ventaja para cuando se desea buscar dentro de los contenidos de una biblioteca. Sin embargo, algo que no se ha implementado en la mayor\'ia de ellas es que de \emph{esa} base de datos se puedan crear, de manera inmediata, las bibliograf\'ias que a veces tanto tiempo nos cuesta crear. M\'as adelante veremos que esto se podr\'ia programar y se podr\'ia ligar a documentos de Microsoft Word o \LaTeX .\\

Otro proyecto similar ser\'ia la creaci\'on de una base de datos con todas las toxicidades de todos los reactivos con los que se vaya trabajando. De crearla as\'i, se podr\'ia obtener la tabla de toxicidades para cada laboratorio solo buscando los reactivos a utilizar, y sin tener que leer la hoja de seguridad entera. Es cierto que al ver la hoja de seguridad uno aprende c\'omo es que funcionan ellas, pero repetir lo mismo durante todos los laboratorios de una carrera resulta tedioso. Esto, como se ver\'a adelante, tambi\'en se podr\'ia programar y dejar creado para futuras generaciones.\\

Ambos proyectos ser\'ian interesantes para quien los quisiera llevar a cabo como ejercicio. No son nada complicados, aunque s\'i algo tediosos, puesto que las bases de datos se tendr\'ian que ir llenando al principio. Para quien se desee aventurar, esto podr\'ia ser un proyecto muy interesante para estudiantes de pregrado.

\subsection{Comentarios Finales}
Felicidades, has completado el segundo d\'ia del taller de QCA. Ahora ya tienes idea de qu\'e es una base de datos, qu\'e se puede hacer con ella y c\'omo hacerlo. Como dijimos en alg\'un momento durante el desarrollo, el uso de SQL es menor en estos d\'ias gracias a los ORMs que facilitan mucho del trabajo. Sin embargo, conocer c\'omo manejar una base de datos es de vital importancia en un mundo en el que todo se almacena en ellas.\\

Si deseas continuar aprendiendo sobre el tema, ser\'ia recomendable que buscaras en internet tutoriales, ejemplos y las instrucciones detalladas de todos los comandos que existen en cada base de datos. Tambi\'en es conveniente probar otras bases de datos como MySQL o PostgreSQL. Con eso ser\'ia suficiente para decir que ya puedes hacer uso de ellas.\\

Felicidades nuevamente, nos vemos ma\~nana para aprender sobre control de revisiones. \'Animo!

\subsection{Glosario de comandos sencillos}
\begin{small}

\begin{itemize}
\item \textbf{.help}: Solicita la p\'agina de ayuda de SQLite.
\item \textbf{.tables}: Muestra qu\'e tablas hay en la base de datos actualmente.
\item \textbf{.headers ON/OFF}: Activa o desactiva que se muestren los encabezados al desplegar el resultado de una consulta.
\item \textbf{.mode}: Cambia el formato para el despliegue del resultado de una consulta. Opciones: \textit{csv}, \textit{column}, \textit{html}, \textit{insert}, \textit{line}, \textit{list}, \textit{tabs}, \textit{tcl}.
\item \textbf{.output FILE}: Especifica el archivo en el que se van a almacenar los resultados desplegados por el administrador.
\item \textbf{.dump TABLE*}: Generar SQL de creaci\'on y llenado, desde una base de datos ya hecha. Puede tratarse de una tabla individual o de toda la base de datos.
\item \textbf{.schema TABLE}: Generar SQL para la creaci\'on de una tabla dada.
\item \textbf{.read FILE}: Leer SQL de un archivo dado.
\item \textbf{.exit}: Salir del programa.
\item \textbf{.quit}: Salir del programa.
\item \textbf{.import FILE TABLE}: Importar datos desde un arhivo dado, hacia una tabla espec\'ifica.
\item \textbf{SELECT}: Seleccionar y mostrar campos.
\item \textbf{FROM}: Especifica una tabla a la cual se debe hacer referencia.
\item \textbf{WHERE}: Abre la posibilidad a filtrar los resultados mediante condiciones.
\item \textbf{DISTINCT}: Elimina duplicados de una lista de entradas.
\item \textbf{ORDER BY}: Ordena las entradas de un campo en particular.
\item \textbf{DESC}: Modifica un ordenamiento para que sea al rev\'es.
\item \textbf{AND}: Operador l\'ogico que permite otra condici\'on.
\item \textbf{LIKE}: Compara entradas y revisa que alguna se parezca a una expresi\'on dada.
\item \textbf{JOIN}: Junta una tabla con otra.
\item \textbf{ON}: Especifica mediante qu\'e campos es que se juntan dos tablas.
\item \textbf{CREATE TABLE}: Crea una tabla.
\item \textbf{INTEGER}: Tipo de dato - \emph{n\'umero entero}.
\item \textbf{VARCHAR()}: Tipo de dato - \emph{caracteres variables}. Puede coloc\'arsele l\'imite.
\item \textbf{DATE}: Tipo de dato - \emph{fecha}.
\item \textbf{TEXT}: Tipo de dato - \emph{texto}.
\item \textbf{REAL}: Tipo de dato - \emph{n\'umero real}.
\item \textbf{NOT NULL}: Especifica que el dato no puede ser vac\'io; no puede ser \inlinecode{NULL}.
\item \textbf{PRIMARY KEY}: Identificador principal de las entradas en una tabla - llave principal.
\item \textbf{FOREIGN KEY}: Identificador principal de las llaves de una tabla que no es con la que se est\'a trabajando - llave externa.
\item \textbf{REFERENCE}: Especifica una tabla y un campo a los que se debe de hacer referencia si se est\'a creando una tabla.
\item \textbf{INSERT INTO}: Crea y almacena una nueva entrada en una tabla dada.
\item \textbf{VALUES()}: Valores a ser insertados como entrada en una tabla.
\item \textbf{UPDATE}: Actualizar los valores en una tabla.
\item \textbf{SET}: Establece qu\'e campo debe de ser actualizado y c\'omo.
\item \textbf{DELETE}: Elimina entradas de una tabla.
\item \textbf{min()}: Busca el valor m\'inimo en un campo.
\item \textbf{max()}: Busca el valor m\'aximo en un campo.
\item \textbf{avg()}: Calcula la media de los datos en un campo.
\item \textbf{sum()}: Suma todos los datos de un campo.
\item \textbf{count()}: Cuenta cu\'antos datos hay en un campo.
\end{itemize}
\end{small}

\section*{Licencia}

\noindent \includegraphics{img/cc_big.png}

\noindent Taller de Qu\'imica Computacional Aplicada by \href{http://github.com/zronyj/TQCA}{Rony J. Letona} is licensed under a \href{http://creativecommons.org/licenses/by-sa/4.0/}{Creative Commons Attribution-ShareAlike 4.0 International License}.
Based on a work at \url{http://github.com/swcarpentry/bc}.

\end{document}