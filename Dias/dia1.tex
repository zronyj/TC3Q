%
% dia1.tex
% 
% Copyright 2014 Rony J. Letona <rony@zronyj.com>
% 
% This program is free software; you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation; either version 2 of the License, or
% any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
% MA 02110-1301, USA.
%

\documentclass[10pt,letterpaper]{article}
\usepackage[latin1]{inputenc}
\usepackage[spanish]{babel}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{color}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\author{Rony J. Letona}
\title{Taller de Qu\'imica Computacional Aplicada: D\'ia 1}

\definecolor{light-gray}{gray}{0.90}

\newcommand{\tab}[1]{\hspace{.2\textwidth}\rlap{#1}}

\newcommand{\inlinecode}[1]{
\colorbox{light-gray}{\texttt{#1}}
}

\newsavebox{\selvestebox}
\newenvironment{Code}
{
\begin{lrbox}{\selvestebox}%
\begin{minipage}{\dimexpr\columnwidth-2\fboxsep\relax}
\fontfamily{\ttdefault}\selectfont
}
{\end{minipage}\end{lrbox}%
\begin{center}
\colorbox{light-gray}{\usebox{\selvestebox}}
\end{center}
}

\begin{document}
\maketitle

\section{Ejercicios con la l\'inea de comando}

\subsection{Archivos y Directorios}
Navegar dentro del sistema de archivos de Linux puede hacerse por medio de una interfaz gr\'afica. Estas son las que ofrecen ventanas, \'iconos, botones, barras de b\'usqueda, etc. Sin embargo, habr\'an veces en las que ver el contenido de una carpeta no ser\'a pr\'actico por medio de una interfaz gr\'afica. Adem\'as, en ella no se puede crear rutinas de manera inmediata. Por eso se recomienda tener una noci\'on de c\'omo navegar dentro del sistema de archivos mediante la l\'inea de comando. A continuaci\'on haremos algunos ejercicios para comprender mejor c\'omo hacer esto.

\subsubsection{Directorio de Trabajo}
Lo primero que debemos saber antes de movernos hacia otro directorio es en qu\'e directorio nos encontramos ahorita. Para ello vamos a utilizar un comando que nos revelar\'a esa informaci\'on. Abre la terminal (l\'inea de comando), despu\'es del signo \inlinecode{$\sim\$ $} escribe \inlinecode{pwd} y presiona Enter. Cu\'al fuel el resultado? An\'otalo y recu\'erdalo.

\subsubsection{Navegando entre carpetas}
Ahora intentaremos cambiar de lugar dentro del \'arbol de directorios. Ingresa el siguiente comando \inlinecode{cd /} y presiona Enter. Despu\'es de eso, vuelve a revisar cu\'al es el directorio en el que te encuentras. Hay alguna diferencia? Si s\'i, cu\'al y por qu\'e crees que la hubo?

\subsubsection{Listando Contenidos}
Finalmente, ingresa el comando \inlinecode{ls} y presiona Enter. Qu\'e puedes ver all\'i? Reconoces alguno de los archivos que all\'i se te muestran? Toma nota de ellos. Ahora ingresa \inlinecode{cd} solamente y presiona Enter. Repite el procedimiento con \inlinecode{ls} y anota lo que ves. Qu\'e crees que hace el comando \inlinecode{ls}?

\subsection{Creando Cosas}
Todos los archivos en un ordenador son archivos de texto. En algunos, el texto es incomprensible para nosotros; es c\'odigo que solo el ordenador puede leer. Mientras que en otros, este es dise\~nado para ser comprendido por nosotros. Para crear archivos de texto, generalmente usamos procesadores de texto como Word, WordPad en Microsoft Windows. Sin embargo, para crear un simple archivo de texto, a veces hemos utilizado Notepad o Block de Notas. En Linux tambi\'en existen procesadores de texto con una interfaz gr\'afica, como Gedit o Kate. Sin embargo, estos todav\'ia son elaborados. Para esta secci\'on crearemos y borraremos directorios, y haremos una serie de ejercicios entre los que crearemos archivos de texto en la l\'inea de comando y los borraremos despu\'es.

\subsubsection{Directorios}
Para trabajar mejor, vamos a crear un nuevo directorio en donde guardar nuestros ejercicios y pruebas. En la terminal que ten\'iamos del ejercicio anterior, vamos a ingresar un nuevo comando: \inlinecode{mkdir Playground}\\

Para revisar qu\'e es lo que ha pasado, vamos a listar el contenido de el directorio en el que nos hallamos y revisar qu\'e cambios ha habido desde que listamos los contenidos la vez pasada. Notas el nuevo directorio?\\

Ahora procederemos a entrar a ese directorio de la siguiente manera \inlinecode{cd Playground} y luego crearemos un directorio de prueba llamado \emph{Test}. C\'omo lo har\'ias? Int\'entalo!

\subsubsection{Archivos de Texto}
En el caso de los archivos de texto, cuando los creamos en la l\'inea de comando, no seguimos el mismo patr\'on que en una interfaz gr\'afica. En la \'ultima, abrimos el editor, creamos el archivo y finalmente lo guardamos. Si bien esto se puede hacer en algunos editores de la l\'inea de comando, es recomendable nombrar el archivo desde el inicio y no hasta el final. Hagamos una prueba. Ingresa el siguiente comando: \inlinecode{nano mi\_archivo.txt} y analiza lo que ves.\\

Ahora escribe alg\'un mensaje dentro de tu nuevo archivo y ci\'erralo. Lee muy bien cada instrucci\'on que se te de en el proceso. Al final lista el contenido de la carpeta y nota c\'omo es que ahora aparece tu nuevo archivo.

\subsubsection{Eliminar}
Hasta ahora todo va muy bien, sin embargo, estas han sido pruebas y debemos dejar nuestro directorio limpio antes de continuar con el taller. Para ello, necesitamos eliminar tanto el directorio \emph{Test} como nuestro reci\'en-creado archivo. A diferencia de simplemente seleccionar a cada uno y eliminarlos, en la l\'inea de comando generalmente se utilizan dos comandos diferentes: uno para archivos (\inlinecode{rm}) y otro para carpetas (\inlinecode{rmdir}). Intenta eliminar ambos.\\

\textbf{Nota}: Al eliminar un directorio, este tiene que hallarse vac\'io. De no ser as\'i, el comando no dejar\'a que lo elimines  y debes usar otra manera un poco m\'as peligrosa. Si deseas saberla, pregunta por ella.

\subsubsection{Copiar y Pegar}
Una pr\'actica que nos encanta al trabajar editando texto en ordenadores es el de copiar, cortar y pegar. Esto quiz\'a se deba a que no existe un equivalente en el mundo real, excepto quiz\'a por las fotocopias. Sin embargo, estas no son tan fieles como una copia digital: copia $100\%$ id\'entica. Para realizar este tipo de operaciones con nuestros archivos, vamos a copiar un archivo del directorio de documentos a nuestro directorio, y luego vamos a cortar otro archivo del directorio de documentos y lo trasladaremos a nuestro directorio de trabajo.\\

Comenzando, copiaremos un archivo con el siguiente comando: \inlinecode{cp ../TQCA/Data/lorem\_ipsum.txt $\sim$/Playground/} Ahora, debemos tomar en cuenta un par de aspectos importantes. El primero son los dos puntos antes del directorio de documentos. Qu\'e crees que hagan? Y luego est\'a el hecho de que primero pusimos la direcci\'on de todo el archivo, luego solo la ubicaci\'on donde lo \'ibamos a colocar. Anota eso, es importante.\\

Finalmente, cortaremos y pegaremos un archivo. Como ya nos dimos cuenta antes, en estos casos no se copia y pega, sino que se transfiere una copia de manera directa. En este caso es igual, solo que a transferir un archivo en Linux se le denomina \emph{mover}. Por ello, el comando utilizado es \inlinecode{mv} Elimina el archivo \emph{lorem\_ipsum.txt} en tu directorio de trabajo e ingresa este comando en una nueva l\'inea: \inlinecode{mv ../TQCA/Data/lorem\_ipsum.txt $ \sim $/Playground/lorem\_ipsum.txt} El comando es casi igual al de copiado, solo con una diferencia importante. Notas cu\'al es?

\subsection{Tubos y Filtros}
Una de las tareas m\'as dif\'iciles en el mundo actual es el saber qu\'e informaci\'on tomar en cuenta y c\'omo separarla de tods los datos que extraemos de experimentos, de la red y de muchas fuentes de informaci\'on. Esta tarea comienza con simples filtros y peque\~nas rutinas que nos ordenen los resultados de alguna manera. As\'i, la informaci\'on no solo se vuelve m\'as comprensible, sino que tambi\'en se puede notar patrones, tendencias y otras cosas. Es por ello que ahora comenzaremos con otro tipo de operaciones sobre los archivos: aprenderemos a extraer informaci\'on y a realizar m\'as de un comando a la vez con la informaci\'on que tenemos.

\subsubsection{Contando Pedazos}
Una tarea sencilla que podemos usar para extraer algo de informaci\'on de un archivo es contar la cantidad de l\'ineas, palabras o caracteres en \'el. Para esto existe un comando que nos muestra estos 3 resultados de una vez, o solo uno de los 3 si as\'i lo deseamos. Para una peque\~na prueba, comenzaremos con un conteo general: \inlinecode{wc ../TQCA/Data/lorem\_ipsum.txt} Esto debi\'o haberte dado como respuesta los 3 resultados de los que habl\'abamos.\\

Ahora, para contar solo las palabras, intentaremos algo diferente: \inlinecode{wc -w ../TQCA/Data/lorem\_ipsum.txt} Notaste el argumento que agregamos? Intenta descubrir c\'omo contar solo l\'ineas o solo caracteres.\\

Finalmente, si quisieramos ver cu\'antas palabras hay en todos los archivos de texto contenidos en la carpeta de documentos, podemos hacer lo siguiente: \inlinecode{wc -w ../TQCA/Data/*.txt} Aqu\'i tenemos algo muy interesante que notar. En vez de usar un nombre para denotar un archivo en particular, utilizamos un \inlinecode{*}. Este nos permite referirnos a \emph{todos} los archivos a la vez. Terminar con la extensi\'on \inlinecode{.txt} filtra los resultados dejando solo a aquellos archivos con \emph{esa} extensi\'on en particular. Intenta repetir el ejercicio con la cantidad de l\'ineas de cada archivo.

\subsubsection{Tubos y Ordenando Listas}
Y de qu\'e nos sirve ahora tener todos los resulatdos all\'i? Pues ... es cierto. Esto no dice mucho. Pero qu\'e pasar\'ia si pudieramos trabajar m\'as con esos resultados? Pues esa es la idea de los tubos! Tubo se le llama al comando que nos permite usar la informaci\'on de salida de un comando, como informaci\'on de entrada del siguiente. En la l\'inea de comando de Linux, esto se hace mediante este caracter: \inlinecode{|} Hagamos un ejercicio.\\

Vamos a comenzar donde lo dejamos la vez pasada: con una lista de archivos y el conteo de la cantidad de palabras en cada uno. Ahora vamos a intentar ordenar los resultados. Como siempre, se sigue la convenci\'on de ir en el orden alfab\'etico. Intentemos, pues, ordenar los resultados. Para eso ingresa lo siguiente en tu l\'inea de comando: \inlinecode{wc -w ../TQCA/Data/*.txt | sort}\\

Creo que inmediatamente notaste los cambios. Agregamos el tubo (en ingl\'es \emph{pipe}) y agregamos un comando para ordenar nuestros resultados: \inlinecode{sort} Al fin tenemos todo ordenado, o no? Lo \'unico que no est\'a bien con el resultado es el total. El total, siendo un n\'umero mayor deber\'ia de ir al final. Para eso quiz\'a sea necesario agregar un \'ultimo argumento. Ingresa: \inlinecode{wc -w ../TQCA/Data/*.txt | sort -n} Ahora obtuvimos el resultado deseado; solo hab\'ia que pedirle al comando de ordenar, que lo hiciera de manera num\'erica.

\subsubsection{Hallando cosas}
Al trabajar con muchos archivos, uno de los problemas con los que nos encontramos seguido es querer aislar solo algunos de ellos. Son bastantes los casos en los que un programa produce varios archivos de salida: resultados, documentaci\'on de la corrida, errores, etc. A nosotros quiz\'a solo nos interese el de los resultados. Haremos un ejercicio para demostrar c\'omo se hace esto de manera sencilla. Ingresa en tu l\'inea de comando lo siguiente: \inlinecode{find ../TQCA/Data/*ipsum*} y observa el resultado. Piensa y discute un momento sobre qu\'e otro comando que ya conoces podr\'ia generar el mismo resultado.\\

Hasta ahora hemos trabajado con archivos solamente, no con su contenido. A lo m\'as que hab\'iamos llegado es a escribir dentro de un archivo con \inlinecode{nano}. Pero qu\'e pasa si queremos ver lo que hay dentro de un archivo sin editarlo? Qu\'e pasa si deseamos buscar cosas dentro del contenido? Para eso vamos a utilizar dos nuevos comandos. El primero nos permitir\'a ver el contenido de un archivo de texto sin abrirlo. Hagamos una prueba. Ingresa \inlinecode{cat ../TQCA/Data/lorem\_ipsum.txt} y observa qu\'e pasa.\\

Como te habr\'as dado cuenta, se muestra el contenido de todo el archivo. Esto puede ser lo que buscamos, o puede que no, ya que a veces, es solo el principio o el final del archivo lo que necesitamos. Para eso podemos usar \inlinecode{head -5} si quisieramos las primeras 5 l\'ineas de un archivo, por ejemplo. O en el caso de querer las \'ultimas 3, podemos ingresar \inlinecode{tail -3}. Por supuesto, los n\'umeros los podemos cambiar, pero eso depender\'a de lo que querramos en ese momento.\\

Ahora que ya sabemos c\'omo mostrar el texto de un archivo de formar total y parcial, vamos a buscar algo dentro de \'el. Para ello vamos utilizar un nuevo comando: \inlinecode{grep}. Este comando busca por expresiones regulares dentro de un texto y devuelve las l\'ineas en el texto que contengan esa expresi\'on. Una \emph{expresi\'on regular} puede ser una palabra o algunas f\'ormulas que permiten hallar patrones dentro del texto. En este caso vamos a proceder buscando un patr\'on sencillo dentro de un archivo con mucha informaci\'on. Ingresa esto en la terminal y comenta sobre el resultado \inlinecode{cat ../TQCA/Data/data.csv | grep 199}. Hallamos entonces a todos los premios nobel en qu\'imica de la d\'ecada de los 90. Sin embargo, obtenemos tambi\'en un resultado que no nos interesa: la \'ultima l\'inea. Para eso, podemos contar cu\'antas l\'ineas hay y as\'i seleccionar solo las que deseamos. Antes de darte la manera de hacer esto, piensa un momento en c\'omo llevar a cabo esta tarea con lo que ya sabes.\\

Para resolver el problema anterior, lo que hacemos es agregar otro \emph{pipe} al comando que ya ten\'iamos, contar las l\'ineas y con \inlinecode{head} seleccionar solo las que deseamos. En otras palabras, hacemos esto:\\
\inlinecode{cat ../TQCA/Data/data.csv | grep 199 | wc -l}\\
lo cual debe de darte como resultado \inlinecode{19}. La \'unica l\'inea que deseamos eliminar es la \'ultima, por lo que seleccionamos solo 18 l\'ineas:\\
\inlinecode{cat ../TQCA/Data/data.csv | grep 199 | head -18}\\
De esa forma tenemos al listado de todos los premios nobel en qu\'imica de la d\'ecada de los 90s.

\subsubsection{Filtrando Resultados}
Los resultados obtenidos del \'ultimo ejercicio ya son algo que nos provee informaci\'on r\'apida sobre el contenido de un archivo. No obstante, si desearamos solo el a\~no, el nombre y el apellido de cada premio nobel de qu\'imica, tenemos que hacer un \'ultimo arreglo. Como notamos de los resultados, el documento que utilizamos usa comas para dividir los campos. Y si ponemos atenci\'on, son las divisiones 1, 5 y 6 las que nos interesan para obtener la informaci\'on antes mencionada. Veamos c\'omo hacer esto. En la terminal ingresa:\\
\inlinecode{cat ../TQCA/Data/data.csv | grep 199 | head -18 | cut -d , -f 1,5,6}\\
Observa los resultados y comenta sobre qu\'e crees que hace cada parte del nuevo comando y argumentos que se utilizaron ahora.\\

Finalmente, tener resultados as\'i en la l\'inea de comando puede ser \'util a veces, pero en el caso de haber extra\'ido informaci\'on importante, quiz\'a es deseable almacenar esto en otro archivo. Ahora, en vez de copiar y pegar los resultados obtenidos del ejercicio anterior, vamos a alargar nuestro comando un poco m\'as. Esta vez vamos a agregar un peque\~no signo m\'as: \inlinecode{>}. Este nos permitir\'a guardar los resultados obtenidos en un archivo de la siguiente forma:\\
\inlinecode{cat ../TQCA/Data/data.csv | grep 199 | head -18 | cut -d , -f 1,5,6 > \ mi\_archivo.txt}\\
Despu\'es de ejecutar eso, como no obtuviste un resultado, deseo que veas cu\'al es el contenido de tu directorio de trabajo y que lo comentes con los dem\'as.

\subsection{Ciclos}
Perfecto, ahora ya sabemos c\'omo trabajar con un archivo. El asunto es que muchas veces, en especial cuando muestreamos, vamos a tener muchos datos en diferentes archivos. Cada archivo merecer\'a nuestra atenci\'on, puesto que los datos en ellos nos permitir\'an realizar una investigaci\'on o un estudio.\\

En esta secci\'on vamos a ver c\'omo trabajar de manera repetitiva. Esto nos permitir\'a trabajar con varios archivos: uno a la vez, pero sin tener que escribir c\'odigo para cada uno de ellos sino para todos de un solo. Para eso vamos a aprender sobre ciclos.

\subsubsection{for ... in ...}
El ciclo m\'as pr\'actico suele ser el ciclo \inlinecode{for}. Realmente, como casi todas las cosas dentro de un ordenador est\'an enumeradas se les puede enumerar, es muy f\'acil utilizar este tipo de ciclos para resolver cualquier problema de repetici\'on de operaciones. Vamos a ver un ejemplo sencillo de esto. Para eso vamos a utilizar una variable \emph{enu} que nos servir\'a para enumerar. La sintaxis del comando ser\'a as\'i:
\begin{Code}
$\sim$\$ for enum in 1 2 3 4 5 6 7 8 9 0\\
>\ do\\
>\ echo \$enum\\
>\ done
\end{Code}

Esta vez hemos incluido varias cosas. As\'i que debemos ir una por una. \inlinecode{for} es el comando inicial que declara el comienzo de toda la instrucci\'on. \inlinecode{in} denota que nuestra variable para enumerar va a tomar los valores que se hallan \emph{en} la lista siguiente. \inlinecode{do} anuncia el comienzo de las instrucciones que van a repetirse. Y finalmente, \inlinecode{done} indica el final de estas instrucciones. Todo esto es necesario en \emph{todo} comando c\'iclico \inlinecode{for}. Como podemos ver, no solo se trata de una palabra, sino que son varias ordenadas de una forma particular.\\

Ahora nos queda explicar qu\'e es \inlinecode{echo} y por qu\'e es que nuestra variable \inlinecode{enum} ahora comienza con un \inlinecode{\$} \inlinecode{echo} es un comando que nos sirve para mostrar el valor de una variable en la terminal. Nuestra variable \inlinecode{enum} por otra parte, requiere del signo \inlinecode{\$} para poder usar su valor. Si no agregamos ese signo antes de una variable, la terminal no nos dejar\'a usar el valor que tiene almacenado esa variable.

\subsection{Scripts}
Para terminar con nuestra breve introducci\'on a la l\'inea de comando, vamos a intentar combinar todo lo que hemos aprendido y hacer algo interesante con ello. Supongamos que estamos trabajando en una investigaci\'on. Entre nuestros documentos hay ciertos archivos con datos de un estudio de aguas (falso) en el lago de Atitl\'an. Estos datos est\'an en forma de tablas que contienen el pH, la temperatura de la muestra y la profundad a la que se tom\'o para 5 diferentes puntos de muestreo. Un ejemplo es el archivo \emph{Agua\_Ati\_20140224.csv}\\

\begin{Code}
Punto,pH,Temp / $^o$C,Prof / m\\
San Antonio,7.6724475943,23.61061926,10.4545873217\\
Santiago,7.2130122874,21.0422111279,10.677484815\\
San Pedro,7.7370670531,21.3379880926,9.4660710143\\
Santa Maria,7.046375392,20.4230312561,9.3680636119\\
Panajachel,7.7367713079,22.9446999496,10.160015882
\end{Code}

La investigadora principal nos env\'ia un correo electr\'onico solicit\'andonos las medias del pH, temperatura y profundidad para cada uno de los archivos. Adjunto nos env\'ia instrucciones de que utilicemos una herramienta que puede calcular las medias de cada uno de los par\'ametros medidos, pero solo en \textbf{un} archivo. Esa herramienta est\'a dentro de nuestros archivos y se llama \emph{med.sh} Finalmente nos dice que esos datos le urgen para dentro de los pr\'oximos 15 minutos.\\

Hacer el trabajo a mano (un archivo a la vez) es f\'acil si la cantidad de archivos es baja, pero no sabemos si se trata de 3 archivos o de 3000. La idea entonces es automatizar todo el proceso. Desarrollaremos entonces un \emph{script} que lleve a cabo esta tarea por nosotros y nos devuelva los resultados sin preocuparnos nosotros por la cantidad de archivos. Un script no es nada m\'as que una serie de comandos, como los que hemos estado aprendiendo, escritos dentro de un archivo de texto para ser ejecutados secuencial- y autom\'aticamente por el ordenador. De esta forma, solo los escribimos una vez y los podemos volver a utilizar cuantas veces querramos. Comencemos, pues!\\

Lo primero que necesitamos es un pensar que debemos ir haciendo alguna operaci\'on un archivo a la vez. Lo primero que viene a nuestra mente es algo c\'iclico! En ese caso, necesitamos utilizar un comando \inlinecode{for} que vaya accesando cada archivo a la vez.

\begin{Code}
for archivo in \emph{listado de arhivos?}\\
do\\
\emph{calcular las medias de alguna manera}\\
done
\end{Code}

Inmediatamente nos damos cuenta de que necesitamos el listado de los archivos que tengan que ver con agua. C\'omo hac\'amos esto? Es cierto! Tenemos un comando \inlinecode{find} que nos permite hallar eso. Intentamos colocarlo dentro del c\'odigo y ...

\begin{Code}
for archivo in \$(find ../TQCA/Data/Agua*)\\
do\\
\emph{calcular las medias de alguna manera}\\
done
\end{Code}

S\'i, debemos colocar nuestro comando entre par\'entesis y con el signo \inlinecode{\$} para que se genere la lista. As\'i como cuando extra\'iamos el valor de una variable, estamos extrayendo la lista. Genial, ahora ya tenemos la lista. Pero ... nuestra jefa probablemente la querr\'a ordenada. Hmm ... arreglemos eso.

\begin{Code}
for archivo in \$(find ../TQCA/Data/Agua* | sort)\\
do\\
\emph{calcular las medias de alguna manera}\\
done
\end{Code}

Perfecto! Ahora, antes de comenzar a calcular las medias de los par\'ametros de cada archivo, ser\'ia conveniente mostrar de qu\'e archivo es que se est\'a calculando la media. Agregemos entonces, antes de cada dato, el nombre del archivo.

\begin{Code}
for archivo in \$(find ../TQCA/Data/Agua* | sort)\\
do\\
echo \$archivo\\
\emph{calcular las medias de alguna manera}\\
done
\end{Code}

Ahora s\'i, a calcular las medias. Esto se supone que lo hace la herramienta \emph{med.sh} Pero ... qu\'e es realmente esa herramienta? Pues esto, para nuestra sorpresa, es \textbf{otro} script. Resulta que para calcular las medias de los par\'ametros en un archivo con resultados de un muestreo de aguas, el script se debe de ejecutar de la siguiente forma.\\
\inlinecode{bash med.sh \emph{nombre\_del\_archivo.csv}}\\

Qu\'e es lo que est\'a sucediendo ac\'a? \inlinecode{bash} es el comando que \emph{activa} o \emph{ejecuta} ese script. Luego viene el nombre del script a ejecutar, y termina con el nombre del archivo del cual se est\'a realizando los c\'alculos. Al implementar esto dentro de nuestro script (s\'i, se puede correr un script desde otro script), el c\'odigo se va a ver algo as\'i:

\begin{Code}
for archivo in \$(find ../TQCA/Data/Agua* | sort)\\
do\\
echo \$archivo\\
echo \$(bash med.sh \$archivo)\\
done
\end{Code}

Ya casi terminarmos. Ahora, ser\'ia conveniente saber cu\'ales son los datos que se est\'a calculando en cada columna. Para eso, agregamos otra l\'inea m\'as extrayendo del contenido de cada archivo la primera fila, y de ella los nombres de las columnas excepto la primera que sabemos que son los nombres de los lugares.

\begin{Code}
for archivo in \$(find ../TQCA/Data/Agua* | sort)\\
do\\
echo \$archivo\\
echo \$(cat \$archivo | head -1 | cut -d , -f 2-)\\
echo \$(bash med.sh \$archivo)\\
done
\end{Code}

Excelente, terminamos el script. Pero momento, si se trata de muchos archivos, no podemos esperar a que nos muestre todo en pantalla. Eso ser\'ia poco pr\'actico, pues tendr\'iamos que copi\'arselo y peg\'arselo en un editor de texto, o peor a\'un, en el correo electr\'onico. Para ello, mejor crear un archivo nuevo, e ir agregando los resultados a \'el. Para crear el archivo nuevo r\'apidamente, solo introduciremos alg\'un texto con el comando \inlinecode{$>$}. Y posteriormente iremos agregando cada l\'inea al archivo en vez de mostrarla en pantalla. Esto lo haremos con el comando \inlinecode{$>>$} Este comando no solo introduce texto en un archivo, como su compa\~nero, sino que lo agrega al texto ya existente. Procedamos entonces.

\begin{Code}
echo Medias de los muestreos en el lago de Atitlan $>$\ resultados.txt\\
for archivo in \$(find ../TQCA/Data/Agua* | sort)\\
do\\
echo \$archivo $>>$\ resultados.txt\\
echo \$(cat \$archivo | head -1 | cut -d , -f 2-) $>>$\ resultados.txt\\
echo \$(bash med.sh \$archivo) $>>$\ resultados.txt\\
done
\end{Code}

Finalizamos! Ahora que ya tenemos la idea completa, abrimos nano y escribimos el script, lo guardamos con el nombre que m\'as nos guste (y extensi\'on \emph{sh}) y lo ejecutamos escribiendo \inlinecode{bash nombre\_de\_mi\_script.sh} Al final nos dirigimos a nuestra carpeta de trabajo en donde hallamos el archivo \emph{resultados.txt}, el cual le enviamos a la investigadora principal por correo. Todo sali\'on en tiempo y ahora ya, sino vuelve a pedir esos datos dentro de los pr\'oximos 3 meses, solo tendremos que correr el script nuevamente; la cantidad de archivos/muestreos realizados no importa, pues todo ya est\'a automatizado.

\subsection{Comentarios Finales}
Felicidades, has completado el primer d\'ia del taller de QCA. Ahora ya conoces el alcance y las posibilidades de lo que se puede hacer en una l\'inea de comando de Linux. Esta es, seg\'un muchos, la parte que aparenta ser m\'as complicada y oscura. Int\'entalo, falla y vuelve a intentarlo sin miedo. Nadie es perfecto la primera vez.\\

Si deseas profundizar, lee, experimenta y sigue escribiendo scripts. Para comenzar quiz\'a sea bueno que revises qu\'e es lo que hace \emph{med.sh}. Te recomiendo leer los manuales de cada comando e ir probando qu\'e hace cada uno. Despu\'es de todo, si tus scripts son archivos independientes, no puedes romper nada ni desperdiciar mucho. Al contrario, hay mucho que puedes aprender.\\

Felicidades nuevamente, y nos vemos ma\~nana en la introducci\'on a bases de datos!

\subsection{Glosario de comandos sencillos}
\begin{small}

\begin{itemize}
\item \textbf{man}: muestra p\'aginas o documentos de ayuda sobre un comando en particular. Para salir de la p\'agina de ayuda, presionar \emph{q}.
\item \textbf{whoami}: muestra al usuario activo.
\item \textbf{pwd}: muestra el directorio en el que se est\'a trabajando actualmente.
\item \textbf{ls}: mostrar (listar) el contenido de un directorio.
\item \textbf{cd}: cambia de directorio al directorio que se ponga a continuaci\'on, o regresa al directorio \emph{home} si no se agrega nada.
\item \textbf{mkdir}: crea un nuevo directorio con el nombre que se ponga a continuaci\'on.
\item \textbf{rm}: elimina el archivo que se coloque a continuaci\'on.
\item \textbf{rmdir}: elimina el directorio que se coloque a continuaci\'on. El directorio debe de estar vac\'io.
\item \textbf{nano}: editor de texto en l\'inea de comando. El nombre que se coloque a continuaci\'on ser\'a el nombre del archivo.
\item \textbf{cp}: copia un archivo de un lugar a otro. Se coloca a continuaci\'on el nombre, con ubicaci\'on, del archivo a copiar y despu\'es la ubicaci\'on en donde se colocar\'a la copia.
\item \textbf{mv}: corta y pega un archivo de una ubicaci\'on a otra. Para ello hay que colocar a continuaci\'on el nombre, con ubicaci\'on, del archivo a cortar, y el directorio, con el nombre del archivo, a donde se va a pegar.
\item \textbf{wc}: cuenta la cantidad de l\'ineas y de palabras en un archivo de texto.
\item \textbf{sort}: ordena una lista de palabras en orden alfab\'etico.
\item \textbf{cat}: muestra todo el contenido de un archivo de texto.
\item \textbf{head}: muestra las primeras l\'ineas de un archivo de texto.
\item \textbf{tail}: muestra las \'ultimas l\'ineas de un archivo de texto.
\item \textbf{uniq}: elimina los duplicados adyacentes en una lista de palabras.
\item \textbf{grep}: busca dentro de los archivos por una frase o palabra en particular. Esta se le tiene que dar posterior al comando.
\item \textbf{find}: busca un archivo cuyo nombre tenga una frase o palabra en particular. Esta se le tiene que dar posterior al comando.
\item \textbf{cut}: segmenta y filtra el texto tabulado de un archivo.
\item \textbf{for}: crea ciclos que se mueven a lo largo de una lista dada de elementos.
\end{itemize}
\end{small}

\section*{Licencia}

\noindent \includegraphics{img/cc_big.png}

\noindent Taller de Qu\'imica Computacional Aplicada by \href{http://github.com/zronyj/TQCA}{Rony J. Letona} is licensed under a \href{http://creativecommons.org/licenses/by-sa/4.0/}{Creative Commons Attribution-ShareAlike 4.0 International License}.
Based on a work at \url{http://github.com/swcarpentry/bc}.

\end{document}