%
% sesion1.tex
% 
% Copyright 2017 Rony J. Letona <zronyj@gmail.com>
% 
% This program is free software; you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation; either version 2 of the License, or
% any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
% MA 02110-1301, USA.
%

\documentclass[10pt,letterpaper]{article}
\usepackage[latin1]{inputenc}
\usepackage[spanish]{babel}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{color}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\author{Rony J. Letona}
\title{Taller de Qu\'imica Computacional Aplicada: Sesi\'on 1}

\definecolor{light-gray}{gray}{0.90}

\newcommand{\tab}[1]{\hspace{.2\textwidth}\rlap{#1}}

\newcommand{\inlinecode}[1]{
\colorbox{light-gray}{\texttt{#1}}
}

\newsavebox{\selvestebox}
\newenvironment{Code}
{
\begin{lrbox}{\selvestebox}%
\begin{minipage}{\dimexpr\columnwidth-2\fboxsep\relax}
\fontfamily{\ttdefault}\selectfont
}
{\end{minipage}\end{lrbox}%
\begin{center}
\colorbox{light-gray}{\usebox{\selvestebox}}
\end{center}
}

\begin{document}
\maketitle

\section{Ejercicios con la l\'inea de comando}

\subsection{Archivos y Directorios}
Navegar dentro del sistema de archivos de Linux puede hacerse por medio de una interfaz gr\'afica. Estas son las que ofrecen ventanas, \'iconos, botones, barras de b\'usqueda, etc. Sin embargo, habr\'an veces en las que ver el contenido de una carpeta no ser\'a pr\'actico por medio de una interfaz gr\'afica. Adem\'as, en ella no se puede crear rutinas de manera inmediata. Por eso se recomienda tener una noci\'on de c\'omo navegar dentro del sistema de archivos mediante la l\'inea de comando. A continuaci\'on haremos algunos ejercicios para comprender mejor c\'omo hacer esto.

\subsubsection{Directorio de Trabajo}
Lo primero que debemos saber antes de movernos hacia otro directorio es en qu\'e directorio nos encontramos ahorita. Para ello vamos a utilizar un comando que nos revelar\'a esa informaci\'on. Abre la terminal (l\'inea de comando), despu\'es del signo \inlinecode{$\sim\$ $} escribe \inlinecode{pwd} y presiona Enter. Cu\'al fuel el resultado? An\'otalo y recu\'erdalo.

\subsubsection{Navegando entre carpetas}
Ahora intentaremos cambiar de lugar dentro del \'arbol de directorios. Ingresa el siguiente comando \inlinecode{cd /} y presiona Enter. Despu\'es de eso, vuelve a revisar cu\'al es el directorio en el que te encuentras. Hay alguna diferencia? Si s\'i, cu\'al y por qu\'e crees que la hubo?

\subsubsection{Listando Contenidos}
Finalmente, ingresa el comando \inlinecode{ls} y presiona Enter. Qu\'e puedes ver all\'i? Reconoces alguno de los archivos que all\'i se te muestran? Toma nota de ellos. Ahora ingresa \inlinecode{cd} solamente y presiona Enter. Repite el procedimiento con \inlinecode{ls} y anota lo que ves. Qu\'e crees que hace el comando \inlinecode{ls}?

\subsection{Creando Cosas}
Todos los archivos en un ordenador son archivos de texto. En algunos, el texto es incomprensible para nosotros; es c\'odigo que solo el ordenador puede leer. Mientras que en otros, este es dise\~nado para ser comprendido por nosotros. Para crear archivos de texto, generalmente usamos procesadores de texto como Word, WordPad en Microsoft Windows. Sin embargo, para crear un simple archivo de texto, a veces hemos utilizado Notepad o Block de Notas. En Linux tambi\'en existen procesadores de texto con una interfaz gr\'afica, como Gedit o Kate. Sin embargo, estos todav\'ia son elaborados. Para esta secci\'on crearemos y borraremos directorios, y haremos una serie de ejercicios entre los que crearemos archivos de texto en la l\'inea de comando y los borraremos despu\'es.

\subsubsection{Directorios}
Para trabajar mejor, vamos a crear un nuevo directorio en donde guardar nuestros ejercicios y pruebas. En la terminal que ten\'iamos del ejercicio anterior, vamos a ingresar un nuevo comando: \inlinecode{mkdir Playground}\\

Para revisar qu\'e es lo que ha pasado, vamos a listar el contenido de el directorio en el que nos hallamos y revisar qu\'e cambios ha habido desde que listamos los contenidos la vez pasada. Notas el nuevo directorio?\\

Ahora procederemos a entrar a ese directorio de la siguiente manera \inlinecode{cd Playground} y luego crearemos un directorio de prueba llamado \emph{Test}. C\'omo lo har\'ias? Int\'entalo!

\subsubsection{Archivos de Texto}
En el caso de los archivos de texto, cuando los creamos en la l\'inea de comando, no seguimos el mismo patr\'on que en una interfaz gr\'afica. En la \'ultima, abrimos el editor, creamos el archivo y finalmente lo guardamos. Si bien esto se puede hacer en algunos editores de la l\'inea de comando, es recomendable nombrar el archivo desde el inicio y no hasta el final. Hagamos una prueba. Ingresa el siguiente comando: \inlinecode{nano mi\_archivo.txt} y analiza lo que ves.\\

Ahora escribe alg\'un mensaje dentro de tu nuevo archivo y ci\'erralo. Lee muy bien cada instrucci\'on que se te de en el proceso. Al final lista el contenido de la carpeta y nota c\'omo es que ahora aparece tu nuevo archivo.

\subsubsection{Eliminar}
Hasta ahora todo va muy bien, sin embargo, estas han sido pruebas y debemos dejar nuestro directorio limpio antes de continuar con el taller. Para ello, necesitamos eliminar tanto el directorio \emph{Test} como nuestro reci\'en-creado archivo. A diferencia de simplemente seleccionar a cada uno y eliminarlos, en la l\'inea de comando generalmente se utilizan dos comandos diferentes: uno para archivos (\inlinecode{rm}) y otro para carpetas (\inlinecode{rmdir}). Intenta eliminar ambos.\\

\textbf{Nota}: Al eliminar un directorio, este tiene que hallarse vac\'io. De no ser as\'i, el comando no dejar\'a que lo elimines y debes usar otra manera un poco m\'as peligrosa. Si deseas saberla, pregunta por ella.

\subsubsection{Copiar y Pegar}
Una pr\'actica que nos encanta al trabajar editando texto en ordenadores es el de copiar, cortar y pegar. Esto quiz\'a se deba a que no existe un equivalente en el mundo real, excepto quiz\'a por las fotocopias. Sin embargo, estas no son tan fieles como una copia digital: copia $100\%$ id\'entica. Para realizar este tipo de operaciones con nuestros archivos, vamos a copiar un archivo del directorio de documentos a nuestro directorio, y luego vamos a cortar otro archivo del directorio de documentos y lo trasladaremos a nuestro directorio de trabajo.\\

Comenzando, copiaremos un archivo con el siguiente comando: \inlinecode{cp ../TQCA/Data/lorem\_ipsum.txt $\sim$/Playground/} Ahora, debemos tomar en cuenta un par de aspectos importantes. El primero son los dos puntos antes del directorio de documentos. Qu\'e crees que hagan? Y luego est\'a el hecho de que primero pusimos la direcci\'on de todo el archivo, luego solo la ubicaci\'on donde lo \'ibamos a colocar. Anota eso, es importante.\\

Finalmente, cortaremos y pegaremos un archivo. Como ya nos dimos cuenta antes, en estos casos no se copia y pega, sino que se transfiere una copia de manera directa. En este caso es igual, solo que a transferir un archivo en Linux se le denomina \emph{mover}. Por ello, el comando utilizado es \inlinecode{mv} Elimina el archivo \emph{lorem\_ipsum.txt} en tu directorio de trabajo e ingresa este comando en una nueva l\'inea: \inlinecode{mv ../TQCA/Data/lorem\_ipsum.txt $ \sim $/Playground/lorem\_ipsum.txt} El comando es casi igual al de copiado, solo con una diferencia importante. Notas cu\'al es?

\subsection{Permisos y Propiedad}
En muchos casos nos vamos a topar con que nuestro ordenador no nos deja crear un documento nuevo o una carpeta. Tampoco nos deja eliminar algunos archivos o modificarlos. Detente y piensa a qu\'e crees que se debe esto? Nuestro ordenador protege algunos documentos y carpetas. Muchas veces nos toparemos con que el \emph{administrador} tiene que permitirnos algo, porque si no tenemos sus privilegios, no podemos modificar nada.\\

En nuestro caso en particular, el sistema operativo en el que nos encontramos protege algunas cosas. Sin embargo, vamos a aprender que podemos accesar a ellas y permitir su modificaci\'on o negarla seg\'un lo que creas conveniente. Primero debemos de tener claro que, en Linux, cada documento tiene un propietario. Adem\'as de esto, los documentos pueden ser vistos por 3 tipos de usuarios o categor\'ias. Veamos esto directamente.

\subsubsection{Qu\'e [no] se puede hacer?}
Entramos a nuestra carpeta mediante \inlinecode{cd Playground} y luego escribimos \inlinecode{ls -l}. Si ponemos atenci\'on, lo que hicimos fue pedir el listado de documentos dentro de la carpeta, pero esta vez obtuvimos una gran cantidad de informaci\'on. Nos interesa un resultado que se ve algo as\'i \inlinecode{-rw-r--r--}. Vamos a descomponer esto en sus partes:

La secuencia comienza con un caracter que nos dice con qu\'e estamos tratando.
\begin{itemize}
\item \inlinecode{-} es un documento o archivo regular.
\item \inlinecode{d} es un directorio o una carpeta.
\item \inlinecode{l} es un enlace simb\'olico\footnote{Esto lo veremos m\'as adelante}.
\end{itemize}

Luego nos topamos con 3 triadas de caracteres. Estas nos dicen lo que se puede hacer con cada uno por parte de cada usuario o categor\'ia. Y qu\'e se puede hacer con \'el?
\begin{itemize}
\item \inlinecode{r} nos dice que el documento puede ser le\'ido.
\item \inlinecode{w} nos dice que el documento puede ser editado o que puede escribirse en \'el.
\item \inlinecode{x} nos dice que el documento o archivo puede ejecutarse como un programa.
\item \inlinecode{-} nos dice que alguna de las 3 acciones anteriores no puede ser realizada.
\end{itemize}

Ahora que ya entendimos las acciones que se pueden hacer con cada uno, nos debemos preguntar: por qu\'e vienen en triadas? Aqu\'i entra lo de los 3 usuarios o categor\'ias. Un archivo puede ser le\'ido, escrito o ejecutado por: el propietario, el grupo de usuarios al que pertenece y una categor\'ia especial llamada \emph{otros}. Esta \'ultima representa a cualquier usuario (aunque no sea el propietario del documento o alguien en su grupo de trabajo).\\

Entonces, en nuestro caso, de haber obtenido algo como \inlinecode{-rw-r--r--} nos damos cuenta de que tratamos con un documento o archivo regular. Este podemos leerlo y podemos escribir en \'el. Sin embargo, no podemos ejecutarlo! Por otra parte, los miembros de nuestro grupo de trabajo y los otros usuarios pueden leer el documento, pero no pueden hacer nada m\'as con \'el. Esta es la manera en que podemos ir identificando qu\'e permisos tiene cada documento o carpeta con la que nos topamos. Q\'ue pasar\'ia si cambiaras de directorio y revisas los permisos de otros documentos?\\

M\'as interesante que ver los permisos de los documentos, es cambiarlos. Para esto debemos entender que tanto el propietario, el grupo o la categor\'ia otros pueden representarse con una \inlinecode{u}, \inlinecode{g} u \inlinecode{o} respectivamente. Ahora vamos a cambiar los permisos de un documento. Para agregar permisos utilizamos un \inlinecode{+}, mientras que para quitarlos utilizamos un \inlinecode{-}. Pero el comando que realmente cambia los permisos es \inlinecode{chmod}. Entonces, para agregarle permisos de lectura y escritura a alg\'un documento \textit{mi\_documento.txt}, escribimos \inlinecode{chmod u+rw mi\_documento.txt} Ahora, si deseamos quitarle permisos de ejecuci\'on a un programa peque\~no \textit{mi\_programa.sh}, escribimos\\
\inlinecode{chmod u-x mi\_programa.sh}. Si nos damos cuenta, lo que hicimos fue cambiar permisos para el propietario nada m\'as. Si desearamos cambiar permisos para el grupo de usuarios actual u \emph{otros}, podemos reemplazar la \inlinecode{u} por una \inlinecode{g} o una \inlinecode{o} respectivamente.

\subsubsection{De qui\'en [no] es esto?}

Ya entendimos c\'omo se quita y pone permisos, a qui\'en darle los permisos y c\'omo averiguar cu\'ales son. Lo que nos queda ahora es saber c\'omo cambiar el propietario de un documento o el grupo al que este pertenece. Veamos c\'omo hacer esto. Si deseamos saber qu\'e usuario es el propietario de un documento, lo que debemos de hacer es igual a lo que vimos en la secci\'on anterior: \inlinecode{ls -l}. Despu\'es de cada una de las representaciones de permisos, vienen 2 nombres. En nuestro caso probablemente ser\'an \inlinecode{mint} y \inlinecode{mint}, pero porque tanto el usuario que estamos usando como el grupo en el que este se encuentra se llaman \inlinecode{mint}. En muchas ocasiones nos veremos frente a casos en donde el usuario y el grupo son distintos (e.g. nuestro usuario es nuestro nombre y el grupo es el grupo de trabajo de la empresa o equipo de investigaci\'on en el que nos hallamos).\\

Si ya sabemos a qui\'en pertenece cada documento y en qu\'e grupo est\'a, lo que nos queda es saber c\'omo cambiar esto. Al igual que en el caso anterior, existe un comando que hace el cambio de propietario. Este es el comando \inlinecode{chown}. Para cambiar un documento \textit{mi\_documento.txt} del usuario actual al usuario \textit{root}, por ejemplo, lo que debemos escribir es \inlinecode{chown root mi\_documento.txt}\footnote{Si tu ordenador te dice que esta operaci\'on no es permitida, no entres en p\'anico. Pregunta por la manera de arreglar esto; no es nada complicada.}. Si en vez de cambiar el usuario al que pertenece el documento dese\'aramos cambiar el grupo en el que se encuentra, escribimos \inlinecode{chown :root mi\_documento.txt}. Finalmente, si deseamos cambiar ambas cosas a la vez (asumiendo que previamente cambiamos ambas en un documento que hab\'iamos elegido), escribimos \inlinecode{chown mint:mint mi\_documento.txt}. Qu\'e entendimos de esto? Qu\'e indican los dos puntos a la hora de cambiar propietarios y grupos? Comenta con tu compa\~nero de al lado.\\

Ya que entendimos que existen diferentes tipos de permisos, de propietarios y de grupos para cada documento dentro de nuestro ordenador, pensemos un momento y comentemos con nuestros compa\~neros sobre las implicaciones que esto tiene. Por qu\'e tanto permiso y tanta distinci\'on? Qu\'e se gana al restringir lo que se cada persona puede hacer con distintos documentos o programas? Qu\'e impacto tiene esto en la seguridad y eficiencia de nuestro ordenador?

\subsection{V\'inculos}
Cuando utilizamos un ordenador por primera vez, aprendemos el concepto de un \emph{Acceso Directo} o un \emph{Hiperv\'inculo}. Esto solo resulta ser un nombre o un \'icono que apunta a otro documento o programa. Cuando lo presionamos o hacemos doble click sobre \'el, nuestro ordenador va a la direcci\'on contenida en este nombre y abre o ejecuta un documento. Esto es muy com\'un en Windows. En Linux no se acostumbra tanto a trabajar con esto, aunque s\'i existe un equivalente que vamos a ver en esta secci\'on.\\

Un v\'inculo o \emph{link} puede ser representado por un documento, \'icono o nombre dentro de nuestro sistema operativo. En Linux existen dos tipos de v\'inculos: los duros y los suaves o simb\'olicos. La diferencia es bastante sencilla, pero vamos a ver un ejemplo para entender c\'omo se hace cada uno.

\subsubsection{V\'inculos Duros}
Este es el tipo de v\'inculo m\'as sencillo de hacer. Para esto vamos a escoger (o crear) un documento \emph{mi\_documento.txt} y vamos a crear un v\'inculo de \'el. Para ello escribimos \inlinecode{ln mi\_documento.txt nuevo\_documento.txt}. Si ponemos atenci\'on, dentro de nuestra carpeta donde estaba el documento, acaba de aparecer otro llamado \emph{nuevo\_documento.txt}. Es m\'as! Si revisamos el contenido de este, nos daremos cuenta que es id\'entico al de nuestro documento original. Podr\'iamos hacer modificaciones al contenido de uno, que las ver\'iamos reflejadas en el otro. Podr\'iamos ver c\'omo se ven estos documentos al escribir \inlinecode{ls -l}. Podr\'iamos tambi\'en cambiar el nombre de \emph{mi\_documento.txt} a otra cosa y revisar el contenido de ambos otra vez notando que este sigue siendo el mismo. Sin embargo, \emph{nuevo\_documento.txt} parece ser un documento; no hay nada que evidencie que solo sea un nombre o un \'icono. Qu\'e estar\'a pasando? Comenta con tu compa\~nero de al lado e intenta explicarlo. En el \'interin, vamos a pasar a los v\'inculos suaves o simb\'olicos.

\subsubsection{V\'inculos Simb\'olicos}
La diferencia entre el comando para crear v\'inculos duros y simb\'olicos es muy sencilla. Para crear un v\'inculo simb\'olico de un documento \emph{mi\_documento\_2.txt} escribimos \inlinecode{ls -s mi\_documento\_2.txt nuevo\_documento\_2.txt}. La diferencia fue sencilla: \inlinecode{-s}. Esto es porque debemos especificar que el v\'inculo es simb\'olico. Ahora vamos a realizar todas las pruebas que realizamos en el caso anterior. Primero revisaremos el contenido de ambos documentos para ver si es el mismo. Ya? Ahora pasemos a cambiar el contenido en uno y ver si ese cambio es evidente en los dos. Hasta aqu\'i todo bien. Qu\'e pasar\'a si vemos la representaci\'on en el listado con \inlinecode{ls -l}? Finalmente vemos un cambio! Claramente vemos que nuestro nuevo documento tiene color diferente, comienza su sistema de permisos con \inlinecode{l} y apunta (con una flecha) hacia el documento original. Ahora cambiaremos el nombre de \emph{mi\_documento\_2.txt} y volvemos a revisar el contenido de los dos. Problema! El documento parece no existir. Esto lo vemos m\'as claro si volvemos a escribir \inlinecode{ls -l}. Parece ser que nuestro v\'inculo no existe. Qu\'e habr\'a pasado? Por qu\'e es que esto ya no funciona? Disc\'utelo con tu compa\~nero de al lado e intenta ampliar tu explicaci\'on anterior sobre v\'inculos.

\subsubsection{Explicaci\'on}
Los documentos en nuestro ordenador son solo informaci\'on guardada en un disco duro. Sin embargo, esta no tiene un orden en particular! C\'omo sabe nuestro ordenador d\'onde hallar las cosas, entonces? De la misma manera en que nosotros hallamos la casa de un amigo la primera vez que vamos: utilizando direcciones. El disco duro contiene una tabla en la que guarda todos los nombres de los documentos en nuestro ordenador y sus direcciones en el disco duro. Entonces, al referirnos al nombre de un documento para abrirlo, nuestro ordenador busca en la tabla del disco duro, adquiere la direcci\'on y, coloc\'andose en la posic\'on del disco indicada por la direcci\'on, lee el contenido y nos muestra el documento \emph{abierto}.\\

Y qu\'e tiene que ver esto con los v\'inculos? Que ahora que sabemos que el nombre de un documento y su contenido son dos cosas independientes, podemos entender mejor qu\'e hace cada v\'inculo. Un v\'inculo duro es solo otro nombre dentro de la tabla de direcciones del disco duro, pero apuntando a la misma direcci\'on de un documento existente; la del documento del que dese\'abamos un v\'inculo. Un v\'inculo simb\'olico es un nombre dentro de la tabla de direcciones en el disco duro, pero apuntando a otro nombre en la misma tabla. Por eso al cambiar el nombre de un documento, su v\'inculo simb\'olico deja de funcionar (el nombre al que se refer\'ia ya no existe) mientras que un v\'inculo duro no (el contenido del documento no se ha movido, as\'i que la direcci\'on sigue siendo la misma).

\subsection{Tubos y Filtros}
Una de las tareas m\'as dif\'iciles en el mundo actual es el saber qu\'e informaci\'on tomar en cuenta y c\'omo separarla de todos los datos que extraemos de experimentos, de la red y de muchas fuentes de informaci\'on. Esta tarea comienza con simples filtros y peque\~nas rutinas que nos ordenan los resultados de alguna manera. As\'i, la informaci\'on no solo se vuelve m\'as comprensible, sino que tambi\'en se puede notar patrones, tendencias y otras cosas. Es por ello que ahora comenzaremos con otro tipo de operaciones sobre los archivos: aprenderemos a extraer informaci\'on y a realizar m\'as de un comando a la vez con la informaci\'on que tenemos.

\subsubsection{Contando Pedazos}
Una tarea sencilla que podemos usar para extraer algo de informaci\'on de un archivo es contar la cantidad de l\'ineas, palabras o caracteres en \'el. Para esto existe un comando que nos muestra estos 3 resultados de una vez, o solo uno de los 3 si as\'i lo deseamos. Para una peque\~na prueba, comenzaremos con un conteo general: \inlinecode{wc ../TQCA/Data/lorem\_ipsum.txt} Esto debi\'o haberte dado como respuesta los 3 resultados de los que habl\'abamos.\\

Ahora, para contar solo las palabras, intentaremos algo diferente: \inlinecode{wc -w ../TQCA/Data/lorem\_ipsum.txt} Notaste el argumento que agregamos? Intenta descubrir c\'omo contar solo l\'ineas o solo caracteres.\\

Finalmente, si quisieramos ver cu\'antas palabras hay en todos los archivos de texto contenidos en la carpeta de documentos, podemos hacer lo siguiente: \inlinecode{wc -w ../TQCA/Data/*.txt} Aqu\'i tenemos algo muy interesante que notar. En vez de usar un nombre para denotar un archivo en particular, utilizamos un \inlinecode{*}. Este nos permite referirnos a \emph{todos} los archivos a la vez. Terminar con la extensi\'on \inlinecode{.txt} filtra los resultados dejando solo a aquellos archivos con \emph{esa} extensi\'on en particular. Intenta repetir el ejercicio con la cantidad de l\'ineas de cada archivo.

\subsubsection{Tubos y Ordenando Listas}
Y de qu\'e nos sirve ahora tener todos los resulatdos all\'i? Pues ... es cierto. Esto no dice mucho. Pero qu\'e pasar\'ia si pudieramos trabajar m\'as con esos resultados? Pues esa es la idea de los tubos! Tubo se le llama al comando que nos permite usar la informaci\'on de salida de un comando, como informaci\'on de entrada del siguiente. En la l\'inea de comando de Linux, esto se hace mediante este caracter: \inlinecode{|} Hagamos un ejercicio.\\

Vamos a comenzar donde lo dejamos la vez pasada: con una lista de archivos y el conteo de la cantidad de palabras en cada uno. Ahora vamos a intentar ordenar los resultados. Como siempre, se sigue la convenci\'on de ir en el orden alfab\'etico. Intentemos, pues, ordenar los resultados. Para eso ingresa lo siguiente en tu l\'inea de comando: \inlinecode{wc -w ../TQCA/Data/*.txt | sort}\\

Creo que inmediatamente notaste los cambios. Agregamos el tubo (en ingl\'es \emph{pipe}) y agregamos un comando para ordenar nuestros resultados: \inlinecode{sort} Al fin tenemos todo ordenado, o no? Lo \'unico que no est\'a bien con el resultado es el total. El total, siendo un n\'umero mayor deber\'ia de ir al final. Para eso quiz\'a sea necesario agregar un \'ultimo argumento. Ingresa: \inlinecode{wc -w ../TQCA/Data/*.txt | sort -n} Ahora obtuvimos el resultado deseado; solo hab\'ia que pedirle al comando de ordenar, que lo hiciera de manera num\'erica.

\subsubsection{Hallando cosas}
Al trabajar con muchos archivos, uno de los problemas con los que nos encontramos seguido es querer aislar solo algunos de ellos. Son bastantes los casos en los que un programa produce varios archivos de salida: resultados, documentaci\'on de la corrida, errores, etc. A nosotros quiz\'a solo nos interese el de los resultados. Haremos un ejercicio para demostrar c\'omo se hace esto de manera sencilla. Ingresa en tu l\'inea de comando lo siguiente: \inlinecode{find ../TQCA/Data/*ipsum*} y observa el resultado. Piensa y discute un momento sobre qu\'e otro comando que ya conoces podr\'ia generar el mismo resultado.\\

Hasta ahora hemos trabajado con archivos solamente, no con su contenido. A lo m\'as que hab\'iamos llegado es a escribir dentro de un archivo con \inlinecode{nano}. Pero qu\'e pasa si queremos ver lo que hay dentro de un archivo sin editarlo? Qu\'e pasa si deseamos buscar cosas dentro del contenido? Para eso vamos a utilizar dos nuevos comandos. El primero nos permitir\'a ver el contenido de un archivo de texto sin abrirlo. Hagamos una prueba. Ingresa \inlinecode{cat ../TQCA/Data/lorem\_ipsum.txt} y observa qu\'e pasa.\\

Como te habr\'as dado cuenta, se muestra el contenido de todo el archivo. Esto puede ser lo que buscamos, o puede que no, ya que a veces, es solo el principio o el final del archivo lo que necesitamos. Para eso podemos usar \inlinecode{head -5} si quisieramos las primeras 5 l\'ineas de un archivo, por ejemplo. O en el caso de querer las \'ultimas 3, podemos ingresar \inlinecode{tail -3}. Por supuesto, los n\'umeros los podemos cambiar, pero eso depender\'a de lo que querramos en ese momento.\\

Ahora que ya sabemos c\'omo mostrar el texto de un archivo de formar total y parcial, vamos a buscar algo dentro de \'el. Para ello vamos utilizar un nuevo comando: \inlinecode{grep}. Este comando busca por expresiones regulares dentro de un texto y devuelve las l\'ineas en el texto que contengan esa expresi\'on. Una \emph{expresi\'on regular} puede ser una palabra o algunas f\'ormulas que permiten hallar patrones dentro del texto. En este caso vamos a proceder buscando un patr\'on sencillo dentro de un archivo con mucha informaci\'on. Ingresa esto en la terminal y comenta sobre el resultado \inlinecode{cat ../TQCA/Data/data.csv | grep 199}. Hallamos entonces a todos los premios nobel en qu\'imica de la d\'ecada de los 90. Sin embargo, obtenemos tambi\'en un resultado que no nos interesa: la \'ultima l\'inea. Para eso, podemos contar cu\'antas l\'ineas hay y as\'i seleccionar solo las que deseamos. Antes de darte la manera de hacer esto, piensa un momento en c\'omo llevar a cabo esta tarea con lo que ya sabes.\\

Para resolver el problema anterior, lo que hacemos es agregar otro \emph{pipe} al comando que ya ten\'iamos, contar las l\'ineas y con \inlinecode{head} seleccionar solo las que deseamos. En otras palabras, hacemos esto:\\
\inlinecode{cat ../TQCA/Data/data.csv | grep 199 | wc -l}\\
lo cual debe de darte como resultado \inlinecode{19}. La \'unica l\'inea que deseamos eliminar es la \'ultima, por lo que seleccionamos solo 18 l\'ineas:\\
\inlinecode{cat ../TQCA/Data/data.csv | grep 199 | head -18}\\
De esa forma tenemos al listado de todos los premios nobel en qu\'imica de la d\'ecada de los 90s.

\subsubsection{Filtrando Resultados}
Los resultados obtenidos del \'ultimo ejercicio ya son algo que nos provee informaci\'on r\'apida sobre el contenido de un archivo. No obstante, si desearamos solo el a\~no, el nombre y el apellido de cada premio nobel de qu\'imica, tenemos que hacer un \'ultimo arreglo. Como notamos de los resultados, el documento que utilizamos usa comas para dividir los campos. Y si ponemos atenci\'on, son las divisiones 1, 5 y 6 las que nos interesan para obtener la informaci\'on antes mencionada. Veamos c\'omo hacer esto. En la terminal ingresa:\\
\inlinecode{cat ../TQCA/Data/data.csv | grep 199 | head -18 | cut -d , -f 1,5,6}\\
Observa los resultados y comenta sobre qu\'e crees que hace cada parte del nuevo comando y argumentos que se utilizaron ahora.\\

Finalmente, tener resultados as\'i en la l\'inea de comando puede ser \'util a veces, pero en el caso de haber extra\'ido informaci\'on importante, quiz\'a es deseable almacenar esto en otro archivo. Ahora, en vez de copiar y pegar los resultados obtenidos del ejercicio anterior, vamos a alargar nuestro comando un poco m\'as. Esta vez vamos a agregar un peque\~no signo m\'as: \inlinecode{>}. Este nos permitir\'a guardar los resultados obtenidos en un archivo de la siguiente forma:\\
\inlinecode{cat ../TQCA/Data/data.csv | grep 199 | head -18 | cut -d , -f 1,5,6 > \ mi\_archivo.txt}\\
Despu\'es de ejecutar eso, como no obtuviste un resultado, deseo que veas cu\'al es el contenido de tu directorio de trabajo y que lo comentes con los dem\'as.

\subsection{Ciclos}
Perfecto, ahora ya sabemos c\'omo trabajar con un archivo. El asunto es que muchas veces, en especial cuando muestreamos, vamos a tener muchos datos en diferentes archivos. Cada archivo merecer\'a nuestra atenci\'on, puesto que los datos en ellos nos permitir\'an realizar una investigaci\'on o un estudio.\\

En esta secci\'on vamos a ver c\'omo trabajar de manera repetitiva. Esto nos permitir\'a trabajar con varios archivos: uno a la vez, pero sin tener que escribir c\'odigo para cada uno de ellos sino para todos de un solo. Para eso vamos a aprender sobre ciclos.

\subsubsection{for ... in ...}
El ciclo m\'as pr\'actico suele ser el ciclo \inlinecode{for}. Realmente, como casi todas las cosas dentro de un ordenador est\'an enumeradas se les puede enumerar, es muy f\'acil utilizar este tipo de ciclos para resolver cualquier problema de repetici\'on de operaciones. Vamos a ver un ejemplo sencillo de esto. Para eso vamos a utilizar una variable \emph{enu} que nos servir\'a para enumerar. La sintaxis del comando ser\'a as\'i:
\begin{Code}
$\sim$\$ for enum in 1 2 3 4 5 6 7 8 9 0\\
>\ do\\
>\ echo \$enum\\
>\ done
\end{Code}

Esta vez hemos incluido varias cosas. As\'i que debemos ir una por una. \inlinecode{for} es el comando inicial que declara el comienzo de toda la instrucci\'on. \inlinecode{in} denota que nuestra variable para enumerar va a tomar los valores que se hallan \emph{en} la lista siguiente. \inlinecode{do} anuncia el comienzo de las instrucciones que van a repetirse. Y finalmente, \inlinecode{done} indica el final de estas instrucciones. Todo esto es necesario en \emph{todo} comando c\'iclico \inlinecode{for}. Como podemos ver, no solo se trata de una palabra, sino que son varias ordenadas de una forma particular.\\

Ahora nos queda explicar qu\'e es \inlinecode{echo} y por qu\'e es que nuestra variable \inlinecode{enum} ahora comienza con un \inlinecode{\$} \inlinecode{echo} es un comando que nos sirve para mostrar el valor de una variable en la terminal. Nuestra variable \inlinecode{enum} por otra parte, requiere del signo \inlinecode{\$} para poder usar su valor. Si no agregamos ese signo antes de una variable, la terminal no nos dejar\'a usar el valor que tiene almacenado esa variable.

\subsection{Scripts}
Para terminar con nuestra breve introducci\'on a la l\'inea de comando, vamos a intentar combinar todo lo que hemos aprendido y hacer algo interesante con ello. Supongamos que estamos trabajando en una investigaci\'on. Entre nuestros documentos hay ciertos archivos con datos de un estudio de aguas (falso) en el lago de Atitl\'an. Estos datos est\'an en forma de tablas que contienen el pH, la temperatura de la muestra y la profundad a la que se tom\'o para 5 diferentes puntos de muestreo. Un ejemplo es el archivo \emph{Agua\_Ati\_20140224.csv}\\

\begin{Code}
Punto,pH,Temp / $^o$C,Prof / m\\
San Antonio,7.6724475943,23.61061926,10.4545873217\\
Santiago,7.2130122874,21.0422111279,10.677484815\\
San Pedro,7.7370670531,21.3379880926,9.4660710143\\
Santa Maria,7.046375392,20.4230312561,9.3680636119\\
Panajachel,7.7367713079,22.9446999496,10.160015882
\end{Code}

La investigadora principal nos env\'ia un correo electr\'onico solicit\'andonos las medias del pH, temperatura y profundidad para cada uno de los archivos. Adjunto nos env\'ia instrucciones de que utilicemos una herramienta que puede calcular las medias de cada uno de los par\'ametros medidos, pero solo en \textbf{un} archivo. Esa herramienta est\'a dentro de nuestros archivos y se llama \emph{med.sh} Finalmente nos dice que esos datos le urgen para dentro de los pr\'oximos 15 minutos.\\

Hacer el trabajo a mano (un archivo a la vez) es f\'acil si la cantidad de archivos es baja, pero no sabemos si se trata de 3 archivos o de 3000. La idea entonces es automatizar todo el proceso. Desarrollaremos entonces un \emph{script} que lleve a cabo esta tarea por nosotros y nos devuelva los resultados sin preocuparnos nosotros por la cantidad de archivos. Un script no es nada m\'as que una serie de comandos, como los que hemos estado aprendiendo, escritos dentro de un archivo de texto para ser ejecutados secuencial- y autom\'aticamente por el ordenador. De esta forma, solo los escribimos una vez y los podemos volver a utilizar cuantas veces querramos. Comencemos, pues!\\

Lo primero que necesitamos es un pensar que debemos ir haciendo alguna operaci\'on un archivo a la vez. Lo primero que viene a nuestra mente es algo c\'iclico! En ese caso, necesitamos utilizar un comando \inlinecode{for} que vaya accesando cada archivo a la vez.

\begin{Code}
for archivo in \emph{listado de arhivos?}\\
do\\
\emph{calcular las medias de alguna manera}\\
done
\end{Code}

Inmediatamente nos damos cuenta de que necesitamos el listado de los archivos que tengan que ver con agua. C\'omo hac\'amos esto? Es cierto! Tenemos un comando \inlinecode{find} que nos permite hallar eso. Intentamos colocarlo dentro del c\'odigo y ...

\begin{Code}
for archivo in \$(find ../TQCA/Data/Agua*)\\
do\\
\emph{calcular las medias de alguna manera}\\
done
\end{Code}

S\'i, debemos colocar nuestro comando entre par\'entesis y con el signo \inlinecode{\$} para que se genere la lista. As\'i como cuando extra\'iamos el valor de una variable, estamos extrayendo la lista. Genial, ahora ya tenemos la lista. Pero ... nuestra jefa probablemente la querr\'a ordenada. Hmm ... arreglemos eso.

\begin{Code}
for archivo in \$(find ../TQCA/Data/Agua* | sort)\\
do\\
\emph{calcular las medias de alguna manera}\\
done
\end{Code}

Perfecto! Ahora, antes de comenzar a calcular las medias de los par\'ametros de cada archivo, ser\'ia conveniente mostrar de qu\'e archivo es que se est\'a calculando la media. Agregemos entonces, antes de cada dato, el nombre del archivo.

\begin{Code}
for archivo in \$(find ../TQCA/Data/Agua* | sort)\\
do\\
echo \$archivo\\
\emph{calcular las medias de alguna manera}\\
done
\end{Code}

Ahora s\'i, a calcular las medias. Esto se supone que lo hace la herramienta \emph{med.sh} Pero ... qu\'e es realmente esa herramienta? Pues esto, para nuestra sorpresa, es \textbf{otro} script. Resulta que para calcular las medias de los par\'ametros en un archivo con resultados de un muestreo de aguas, el script se debe de ejecutar de la siguiente forma.\\
\inlinecode{bash med.sh \emph{nombre\_del\_archivo.csv}}\\

Qu\'e es lo que est\'a sucediendo ac\'a? \inlinecode{bash} es el comando que \emph{activa} o \emph{ejecuta} ese script. Luego viene el nombre del script a ejecutar, y termina con el nombre del archivo del cual se est\'a realizando los c\'alculos. Al implementar esto dentro de nuestro script (s\'i, se puede correr un script desde otro script), el c\'odigo se va a ver algo as\'i:

\begin{Code}
for archivo in \$(find ../TQCA/Data/Agua* | sort)\\
do\\
echo \$archivo\\
echo \$(bash med.sh \$archivo)\\
done
\end{Code}

Ya casi terminarmos. Ahora, ser\'ia conveniente saber cu\'ales son los datos que se est\'a calculando en cada columna. Para eso, agregamos otra l\'inea m\'as extrayendo del contenido de cada archivo la primera fila, y de ella los nombres de las columnas excepto la primera que sabemos que son los nombres de los lugares.

\begin{Code}
for archivo in \$(find ../TQCA/Data/Agua* | sort)\\
do\\
echo \$archivo\\
echo \$(cat \$archivo | head -1 | cut -d , -f 2-)\\
echo \$(bash med.sh \$archivo)\\
done
\end{Code}

Excelente, terminamos el script. Pero momento, si se trata de muchos archivos, no podemos esperar a que nos muestre todo en pantalla. Eso ser\'ia poco pr\'actico, pues tendr\'iamos que copi\'arselo y peg\'arselo en un editor de texto, o peor a\'un, en el correo electr\'onico. Para ello, mejor crear un archivo nuevo, e ir agregando los resultados a \'el. Para crear el archivo nuevo r\'apidamente, solo introduciremos alg\'un texto con el comando \inlinecode{$>$}. Y posteriormente iremos agregando cada l\'inea al archivo en vez de mostrarla en pantalla. Esto lo haremos con el comando \inlinecode{$>>$} Este comando no solo introduce texto en un archivo, como su compa\~nero, sino que lo agrega al texto ya existente. Procedamos entonces.

\begin{Code}
echo Medias de los muestreos en el lago de Atitlan $>$\ resultados.txt\\
for archivo in \$(find ../TQCA/Data/Agua* | sort)\\
do\\
echo \$archivo $>>$\ resultados.txt\\
echo \$(cat \$archivo | head -1 | cut -d , -f 2-) $>>$\ resultados.txt\\
echo \$(bash med.sh \$archivo) $>>$\ resultados.txt\\
done
\end{Code}

Finalizamos! Ahora que ya tenemos la idea completa, abrimos nano y escribimos el script, lo guardamos con el nombre que m\'as nos guste (y extensi\'on \emph{sh}) y lo ejecutamos escribiendo \inlinecode{bash nombre\_de\_mi\_script.sh} Al final nos dirigimos a nuestra carpeta de trabajo en donde hallamos el archivo \emph{resultados.txt}, el cual le enviamos a la investigadora principal por correo. Todo sali\'on en tiempo y ahora ya, sino vuelve a pedir esos datos dentro de los pr\'oximos 3 meses, solo tendremos que correr el script nuevamente; la cantidad de archivos/muestreos realizados no importa, pues todo ya est\'a automatizado.

\subsection{Comentarios Finales}
Felicidades, has completado el primer d\'ia del taller de QCA. Ahora ya conoces el alcance y las posibilidades de lo que se puede hacer en una l\'inea de comando de Linux. Esta es, seg\'un muchos, la parte que aparenta ser m\'as complicada y oscura. Int\'entalo, falla y vuelve a intentarlo sin miedo. Nadie es perfecto la primera vez.\\

Si deseas profundizar, lee, experimenta y sigue escribiendo scripts. Para comenzar quiz\'a sea bueno que revises qu\'e es lo que hace \emph{med.sh}. Te recomiendo leer los manuales de cada comando e ir probando qu\'e hace cada uno. Despu\'es de todo, si tus scripts son archivos independientes, no puedes romper nada ni desperdiciar mucho. Al contrario, hay mucho que puedes aprender.\\

Felicidades nuevamente, y nos vemos ma\~nana en la introducci\'on a bases de datos!

\subsection{Glosario de comandos sencillos}
\begin{small}

\begin{itemize}
\item \textbf{man}: muestra p\'aginas o documentos de ayuda sobre un comando en particular. Para salir de la p\'agina de ayuda, presionar \emph{q}.
\item \textbf{whoami}: muestra al usuario activo.
\item \textbf{pwd}: muestra el directorio en el que se est\'a trabajando actualmente.
\item \textbf{ls}: mostrar (listar) el contenido de un directorio.
\item \textbf{cd}: cambia de directorio al directorio que se ponga a continuaci\'on, o regresa al directorio \emph{home} si no se agrega nada.
\item \textbf{mkdir}: crea un nuevo directorio con el nombre que se ponga a continuaci\'on.
\item \textbf{rm}: elimina el archivo que se coloque a continuaci\'on.
\item \textbf{rmdir}: elimina el directorio que se coloque a continuaci\'on. El directorio debe de estar vac\'io.
\item \textbf{nano}: editor de texto en l\'inea de comando. El nombre que se coloque a continuaci\'on ser\'a el nombre del archivo.
\item \textbf{cp}: copia un archivo de un lugar a otro. Se coloca a continuaci\'on el nombre, con ubicaci\'on, del archivo a copiar y despu\'es la ubicaci\'on en donde se colocar\'a la copia.
\item \textbf{mv}: corta y pega un archivo de una ubicaci\'on a otra. Para ello hay que colocar a continuaci\'on el nombre, con ubicaci\'on, del archivo a cortar, y el directorio, con el nombre del archivo, a donde se va a pegar.
\item \textbf{wc}: cuenta la cantidad de l\'ineas y de palabras en un archivo de texto.
\item \textbf{chmod}: cambia los permisos de lectura, escritura o ejecuci\'on de un documento.
\item \textbf{chown}: cambia el usuario y/o el grupo al que el documento pertenece.
\item \textbf{ln}: crea v\'inculos duros. Para crear v\'inculos simb\'olicos se agrega la bandera \emph{-s}.
\item \textbf{sort}: ordena una lista de palabras en orden alfab\'etico.
\item \textbf{cat}: muestra todo el contenido de un archivo de texto.
\item \textbf{head}: muestra las primeras l\'ineas de un archivo de texto.
\item \textbf{tail}: muestra las \'ultimas l\'ineas de un archivo de texto.
\item \textbf{uniq}: elimina los duplicados adyacentes en una lista de palabras.
\item \textbf{grep}: busca dentro de los archivos por una frase o palabra en particular. Esta se le tiene que dar posterior al comando.
\item \textbf{find}: busca un archivo cuyo nombre tenga una frase o palabra en particular. Esta se le tiene que dar posterior al comando.
\item \textbf{cut}: segmenta y filtra el texto tabulado de un archivo.
\item \textbf{for}: crea ciclos que se mueven a lo largo de una lista dada de elementos.
\end{itemize}
\end{small}

\section*{Licencia}

\noindent \includegraphics{img/cc_big.png}

\noindent Taller de Qu\'imica Computacional Aplicada by \href{http://github.com/zronyj/TQCA}{Rony J. Letona} is licensed under a \href{http://creativecommons.org/licenses/by-sa/4.0/}{Creative Commons Attribution-ShareAlike 4.0 International License}.
Based on a work at \url{http://github.com/swcarpentry/bc}.

\end{document}