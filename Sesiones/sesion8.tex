%
% sesion8.tex
% 
% Copyright 2017 Rony J. Letona <zronyj@gmail.com>
% 
% This program is free software; you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation; either version 2 of the License, or
% any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
% MA 02110-1301, USA.
%

\documentclass[10pt,letterpaper]{article}
\usepackage[latin1]{inputenc}
\usepackage[spanish]{babel}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{color}
\usepackage{float}
\usepackage{upquote}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\author{Rony J. Letona}
\title{Taller de Computaci\'on Cient\'ifica para Ciencias Qu\'imicas: Sesi\'on 8}
\definecolor{light-gray}{gray}{0.90}

\newcommand{\tab}[1]{\hspace{.2\textwidth}\rlap{#1}}

\newcommand{\inlinecode}[1]{
\colorbox{light-gray}{\texttt{#1}}
}

\newsavebox{\selvestebox}
\newenvironment{Code}
{
\begin{lrbox}{\selvestebox}%
\begin{minipage}{\dimexpr\columnwidth-2\fboxsep\relax}
\fontfamily{\ttdefault}\selectfont
}
{\end{minipage}\end{lrbox}%
\begin{center}
\colorbox{light-gray}{\usebox{\selvestebox}}
\end{center}
}

\newcommand{\Picture}[1]
{
	\begin{figure}[H]
	\begin{flushleft}
	\includegraphics[width=\columnwidth]{#1}
	\end{flushleft}
	\end{figure}
}

\begin{document}
\maketitle

\section{Qu\'imica y Biolog\'ia se encuentran con Inform\'atica}
Despu\'es de haber conocido un poco de lo b\'asico en ciencias de la computaci\'on y c\'omo estas se aplican a m\'etodos num\'ericos y matem\'atica, ya vamos teniendo una base m\'as s\'olida sobre c\'omo tratar con nuestro ordenador. Ya no nos da miedo trabajar con la terminal, ya entendemos de qu\'e nos hablan cuando se refieren a base de datos, ya sabemos hacer peque\~nos scripts en un lenguaje de programaci\'on no tan complicado, y ya sabemos llevar control de cambios en un proyecto que tengamos. La diferencia la podemos sentir ya. Ahora vamos a comenzar con las diferentes disciplinas cient\'ificas que utilizan el poder de nuestro ordenador para lograr resultados.\\

El c\'alculo de propiedades y manejo de datos qu\'imicos con t\'ecnicas inform\'aticas se conoce como \textbf{quimioinform\'atica}. Esta rama de la qu\'imica es muy utilizada en todo aquello que involucre dise\~no molecular y hacer sentido de lo que se sabe de las mol\'eculas. Las herramientas para este tipo de c\'alculos no son tan complejas desde un punto de vista matem\'atico, pero pueden llegar a complicarse desde un punto de vista computacional.\\

Vamos a comenzar entonces, estudiando la manera en que nuestro ordenador \emph{ve} las mol\'eculas y c\'omo es que calcula muchas de las propiedades que predecimos. Notaremos que, aunque existen varios paquetes para ir haciendo de la qu\'imica en el ordenador un trabajo f\'acil, no existe uno que logre hacer \emph{todo} todav\'ia. A continuaci\'on vamos a ver qu\'e otras alternativas, adem\'as de SMILES, podemos utilizar para almacenar informaci\'on sobre mol\'eculas.\\

Luego vamos a cambiar un poco el paradigma y veremos un algoritmo muy particular que se utiliza en la rama de \textbf{bioinform\'atica}. Esta rama de la biolog\'ia se enfoca mucho en obtener, almacenar e interpretar informaci\'on gen\'etica y prot\'eica. Por ello, mucho se enfoca en formas de b\'usqueda, alineaci\'on y de comparaci\'on de secuencias de bases de ADN o de amino\'acidos. El algoritmo que vamos a ver hoy hace dos de esas tres cosas: busca y compara segmentos de secuencias.\\

Finalmente vamos a analizar las secuencias aminoac\'idicas de prote\'inas y vamos a preparar una de estas, y una mol\'ecula peque\~na, para realizar un estudio de acoplamiento molecular. Muchos de estos temas son de inter\'es para aquellos que buscan realizar estudios de gen\'omica, dise\~no de f\'armacos o an\'alisis estructural de biomol\'eculas. En esta sesi\'on comenzamos a ver las herramientas que, si las aplicamos bien, ya podemos utilizar para realizar investigaci\'on. Comencemos!

\subsection{Manipulaci\'on de Moleculas y C\'alculo de Propiedades}

Acabamos de ver lo que podemos hacer con Python. Si bien ya hemos visto algo de lo que se puede hacer con \'el relacionado a qu\'imica, no hemos entrado en detalle. Las cosas que se pueden hacer as\'i nos dan muchas posibilidades. Podemos calcular desde propiedades termodin\'amicas hasta descriptores que nos den una idea sobre qu\'e mol\'ecula es y el efecto que puede tener en en alg\'un organismo. Pero vamos por pasos.\\

Lo primero que haremos ser\'a abrir una sesi\'ion en iPython y crear un nuevo documento. Vamos a ir realizando operaciones de manipulaci\'on molecular con dos paquetes simult\'aneamente. El primero es PyBel, una implementaci\'on de OpenBabel dentro de Python. El segundo es RDKit, con este paquete ya hab\'iamos hecho un par de operaciones en la Sesi\'on 5. Comencemos con algo sencillo: importemos ambos paquetes en la misma celda.

\begin{Code}
\%matplotlib inline\\
from pybel import *\\
from rdkit import Chem\\
from rdkit.Chem import AllChem
\end{Code}

\subsubsection{Abrir y Guardar}
Abrir un documento o guardar informaci\'on en \'el es el primer problema con el que nos toparemos cada vez que trabajemos con mol\'eculas. Es importante que recordemos c\'omo se hace, pues al necesitar alguna operaci\'on sobre miles de ellas, este tipo de comando nos facilitar\'a mucho trabajo. Vamos a abrir el siguiente SMILES con ambos paquetes: \inlinecode{CC1=CC=CC=C1}\\

\noindent Para PyBel, vamos a utilizar el siguiente comando: \inlinecode{pmol = readstring("smi", "\ \hspace*{-2mm}CC1=CC=CC=C1")}

\noindent Para RDKit, utilizaremos este otro: \inlinecode{rmol = Chem.MolFromSmiles("\ \hspace*{-2mm}CC1=CC=CC=C1")}\\

Ahora, si dese\'aramos guardar esta mol\'ecula, lo ideal ser\'ia utilizar alg\'un formato un poco m\'as rico en detalles que SMILES. Para ello vamos a agregar una propiedad especial a nuestra mol\'ecula; le vamos a poner nombre.\\

\noindent En el caso de PyBel, el comando es: \inlinecode{pmol.title = "\ \hspace*{-2mm}tolueno"}

\noindent En el caso de RDKit, el comando es: \inlinecode{rmol.SetProp("\_Name", "\ \hspace*{-2mm}tolueno")}\\

En este momento ya vamos a guardar nuestra mol\'ecula. El formato en el que guardaremos las mol\'eculas es importante. Vamos a intentar guardarlas en formato SDF.\\

\noindent Guardar en PyBel puede hacerse de la siguiente manera: \inlinecode{pmol.write("sdf","pybel\_tolueno.sdf")}

\noindent Guardar en RDKit puede hacerse de la siguiente manera: \inlinecode{print( Chem.MolToMolBlock(rmol) )}\\

En ambos casos notaremos un par de cosas extra\~nas. La primera es que PyBel se queja de haber creado un documento sin coordenadas. Sin embargo, si revisamos el directorio en el que estamos trabajando, notaremos que s\'i cre\'o el documento. Lo de las coordenadas lo resolveremos en un momento.\\

En el caso de RDKit, solo nos devolvi\'o un \inlinecode{string} que mostramos con \inlinecode{print()}, pero no guard\'o ning\'un documento. Si dese\'aramos guardar la informaci\'on que genera \inlinecode{Chem.MolToMolBlock(rmol)} debemos guardar este string. Eso se puede hacer con \inlinecode{open("\ \hspace*{-2mm}rdkit\_tolueno.sdf","w")} y \inlinecode{write()}.

\begin{Code}
salida = Chem.MolToMolBlock(rmol)\\
f = open("\ \hspace*{-2mm}rdkit\_tolueno.sdf","w")\\
f.write(salida)\\
f.close()
\end{Code}

\subsubsection{Geometr\'ias 2D y 3D}

Las mol\'eculas no son solo un pu\~nado de \'atomos juntos. Estas poseen un arreglo que llamamos estructura y esta puede ser visualizada en 2 y 3 dimensiones. Esto no es nuevo para nosotros, pero debemos aclar\'arselo a nuestro ordenador. RDKit nos permite calcular y representar las coordenadas en 2 dimensiones. Pero antes de eso, debemos tener a todos los \'atomos involucrados.\\

\noindent Agregamos hidr\'ogenos con PyBel: \inlinecode{pmol.addh()}

\noindent Agregamos hidr\'ogenos con RDKit: \inlinecode{rmol2 = Chem.AddHs(rmol)}\\

Ahora veamos c\'omo es que RDKit puede generar la geometr\'ia 2D. Para ello vamos a escribir lo siguiente: \inlinecode{AllChem.Compute2DCoords(rmol2)}. De esta manera generamos la estructura en 2D almacenando la informaci\'on en cada \'atomo de la mol\'ecula.\\

Pasando a un mejor nivel, vamos a generar las estructuras 3D de la mol\'ecula. En cada caso vale la pena mencionar que existe una teor\'ia un poco m\'as profunda de fondo. En la pr\'oxima sesi\'on veremos qu\'e significa cada una, pero por el momento intentemos seguir la siguiente idea: vamos a utilizar el campo de fuerzas MMFF94.\\

\noindent Para la mol\'ecula en PyBel vamos a escribir: \inlinecode{pmol.make3D(forcefield='mmff94',steps=100)}

\noindent Para la mol\'ecula en RDKit, vamos a escribir un poco m\'as. Necesitaremos hacer algo antes de correr la optimizaci\'on para la geometr\'ia 3D.

\begin{Code}
AllChem.EmbedMolecule(rmol2)\\
AllChem.MMFFOptimizeMolecule(rmol2)
\end{Code}

Al igual que antes, lo que sucedi\'o es que la informaci\'on de la optimizaci\'on geom\'etrica qued\'o guardada en las coordenadas de cada \'atomo. Visualizar nuestras mol\'eculas dentro de iPython es una tarea un tanto m\'as complicada. Por lo mismo, si deseamos verlas, podemos guardarlas nuevamente y verlas utilizando otro programa como Avogadro o PyMOL.

\subsubsection{Subestructuras}
Las siguientes secciones solo se continuar\'an trabajando con \href{http://www.rdkit.org/docs/GettingStartedInPython.html}{RDKit}, pues este tiene las herramientas necesarias. \href{http://openbabel.org/docs/current/UseTheLibrary/Python_Pybel.html}{PyBel}, basado en OpenBabel, se queda un poco corto a partir de este punto. Este generalmente sirve solo para transformaciones y c\'alculos de propiedades sencillas como las coordenadas moleculares o el peso molecular. Tambi\'en es capaz de calcular huellas digitales moleculares, pero ese tema lo veremos m\'as adelante.\\

Las subestructuras son un tema que, aunque al principio no se vea tan obvio, es de gran utilidad. Estas usualmente sirven para hallar mol\'eculas similares dentro de listados de mol\'eculas. En este caso, solo vamos a ver el sencillo caso en el que podemos hallar un benceno dentro de nuestro tolueno. El comando para esto se basa en un principio sencillo: solo se debe saber si una estructura es similar a alguna parte de la otra. Veamos esto.\\

\begin{Code}
patron = Chem.MolFromSmiles("\ \hspace*{-2mm}C1=CC=CC=C1")\\
rmol2.HasSubstructMatch(patron)
\end{Code}

El resultado ser\'a un \inlinecode{bool} que indicar\'a si el patr\'on que utilizamos (un benceno) es o no es parte de la estructura de nuestra mol\'ecula. Vale la pena mencionar que muchas veces lo que buscamos no es que una estructura est\'e en otra, sino que una estructura base (i.e. un \emph{scaffold}) que hemos hallado de otro grupo de mol\'eculas est\'e presente en alguna mol\'ecula de una base de datos. Para eso tendr\'iamos que buscar cierto patr\'on dentro de una base de datos con estructuras.

\subsubsection{Cargas Parciales y Representaci\'on}

Casi desde que comenzamos a estudiar qu\'imica, nos hemos topado con las cargas parciales. Estas son las cargas el\'ectricas que posee cada \'atomo en una mol\'ecula y son responsables de su polaridad y de muchas propiedades como su reactiviad. Para calcular estas cargas existen muchas teor\'ias tambi\'en. El m\'etodo de Gasteiger ser\'a el que nosotros vamos a utilizar esta vez. Vamos a calcular las cargas de nuestra mol\'ecula y de otra m\'as para comparar.

\begin{Code}
AllChem.ComputeGasteigerCharges(rmol2)\\
from rdkit.Chem.Draw import SimilarityMaps\\
pesos = [float(rmol2.GetAtomWithIdx(i).GetProp("\_GasteigerCharge")) for i in range(rmol2.GetNumAtoms())]\\
fig1 = SimilarityMaps.GetSimilarityMapFromWeights(rmol2, pesos, colorMap="jet", contourLines=10)
\end{Code}

Esta estructura nos da algo muy interesante. Notamos como los hidr\'ogenos son relativamente m\'as positivos que el anillo benc\'enico. Intentemos con otra.

\begin{Code}
molx = Chem.MolFromSmiles("\ \hspace*{-2mm}OC1=CC=C(N)C=C1")\\
molx = Chem.AddHs(molx)\\
AllChem.EmbedMolecule(molx)\\
AllChem.MMFFOptimizeMolecule(molx)\\
AllChem.ComputeGasteigerCharges(molx)\\
pesos2 = [float(molx.GetAtomWithIdx(i).GetProp("\_GasteigerCharge")) for i in range(molx.GetNumAtoms())]\\
fig2 = SimilarityMaps.GetSimilarityMapFromWeights(molx, pesos2, colorMap="jet", contourLines=10)
\end{Code}

En este caso se ve m\'as claro el contraste entre los \'atomos. EL anillo no juega un papel tan importante como lo juegan el ox\'igeno y el nitr\'ogeno. Estos realmente son m\'as negativos y vuelven m\'as positivos a los carbonos e hidr\'ogenos que los rodean. As\'i podr\'iamos seguir calculando las cargas y represent\'andolas para evidenciar la superficie de carga molecular. Ahora, sin embargo, pasaremos al \'ultimo tema que nos interesa de manipulaci\'on molecular.

\subsubsection{Descriptores Moleculares}

Un descriptor es simplemente una caracter\'istica molecular que podemos extraer a partir de los \'atomos que conforman a una mol\'ecula, sus enlaces, las subestructuras que forma, la estructura en 2D, la estructura en 3D, sus regiones de carga positiva, negativa o la manera en que interact\'ua con alg\'un solvente. Cada descriptor permite revelar alguna propiedad que le da identidad a alguna mol\'ecula. Ahora vamos a calcular algunos de ellos. M\'as adelante en el taller calcularemos muchos m\'as.\\

Comenzaremos importando la secci\'on de RDKit que nos permitir\'a realizar este tipo de c\'alculos:

\begin{Code}
from rdkit.Chem import Descriptors
\end{Code}

Algunos descriptores ya los hemos calculado. Las cargas parciales pueden ser un descriptor molecular. Pero comencemos con algunos m\'as sencillos: el peso molecular, el n\'umero de enlaces rotables y los donadores y aceptores de puentes de hidr\'ogeno. Cada uno de los siguientes comandos ejecut\'emoslo en una celda distinta.

\begin{Code}
Descriptors.MolWt(rmol2)\\
Descriptors.NumRotatableBonds(rmol2)\\
Descriptors.NumHDonors(rmol2)\\
Descriptors.NumHAcceptors(rmol2)
\end{Code}

Tambi\'en podr\'iamos saber cu\'antos anillos existen en nuestra mol\'ecula con \inlinecode{Descriptors.RingCount(rmol2)} o cu\'al es el \'area superficial polar total de la mol\'ecula con \inlinecode{Descriptors.TPSA(rmol2)}. Los descriptores pueden ser tan complejos que consideren al coeficiente de partici\'on Octanol/Agua \inlinecode{Descriptors.MolLogP(rmol2)} de una mol\'ecula para hallar qu\'e tan lipof\'ilica o hidrof\'ilica es la misma.\\

Lo que debemos recordar es que estos generalmente se utilizan en estudios en los que ya se conocen algunas mol\'eculas que funcionan de la manera en que nosotros deseamos. Si sabemos que 3 pigmentos utilizados en la industria tienen un \'area superficial total similar y un coeficiente de partici\'on Octanol/Agua muy parecido, lo que buscamos es que la mol\'ecula que nosotros estamos dise\~nando tenga valores similares en esos descriptores.\\

Existen muchos m\'as descriptores que vale la pena estudiar. En RDKit podemos hallar una \href{http://www.rdkit.org/docs/GettingStartedInPython.html#list-of-available-descriptors}{lista} con todos los que se hallan en ese paquete. Sin embargo, hay paquetes como \href{http://lifescience.opensource.epam.com/indigo/}{Indigo}, \href{https://cdk.github.io/}{CDK}, \href{https://chm.kode-solutions.net/products_dragon.php}{Dragon}\footnote{Dragon es software comercial, pero puede ser utilizado a trav\'es de \href{http://www.vcclab.org/lab/edragon/}{VCCLab}.} y otros que permiten la creaci\'on de modelos de Relaci\'on de Estructura Actividad/Propiedad. Al utilizar KNIME veremos la utilidad de estos modelos y c\'omo RDKit, Indigo y CDK pueden utilizarse para obtener resultados prometedores.

\subsection{Formatos de Archivos}
Desde que comenzamos la carrera, nos hemos ido dando cuenta c\'omo es que el identificar sustancias es un reto. Desde aquellas f\'ormulas moleculares, nomenclatura b\'asica y estructuras de Lewis, hasta la nomenclatura de compuestos org\'anicos heteroat\'omicos, complejos y p\'eptidos. Durante nuestras carreras siempre ha habido un inter\'es muy fuerte por identificar las sustancias y poder predecir propiedades a partir de esa forma que usamos para representarla. Cuando trabajamos mol\'eculas en nuestro ordenador no es la excepci\'on.\\

Existen muchos formatos de archivo para mol\'eculas. Cada uno se ha ido especializando en alg\'un aspecto que nos ayudar\'a en el c\'alculo y predicci\'on de propiedades moleculares. A continuaci\'on vamos a ir estudiando varios de estos formatos, pero no sin antes haber utilizado una pieza de software que nos facilitar\'a las conversiones. El paquete \href{http://openbabel.org/wiki/Main_Page}{OpenBabel} es una de las piezas de software para qu\'imica m\'as famosas a nivel mundial. Este simplifica el poder \href{https://openbabel.org/docs/dev/Command-line_tools/babel.html}{convertir} una mol\'ecula de un formato al otro. Vamos a ver a continuaci\'on c\'omo se utiliza este con ejemplos. Comencemos con algo que ya sabemos: un SMILES del ibuprofeno.

\subsubsection{Simplified Molecular Input Line Entry Specification - SMILES}
Comenzando en nuestra l\'inea de comando, vamos a crear un nuevo documento llamado \textit{ibuprofen.smi}. Esto lo haremos escribiendo \inlinecode{nano ibuprofen.smi} en la l\'inea de comando y presionando Enter. Dentro del documento de texto, vamos a incluir la siguiente l\'inea: \inlinecode{CC(C)CC1=CC=C(C=C1)C(C)C(O)=O}. Finalmente presionaremos \textbf{Ctrl + X}, \textbf{Y} y Enter para que la informaci\'on se almacene en el archivo. Lo que incluimos es el SMILES del ibuprofeno. Perfecto! Ya creamos nuestro primer archivo con informaci\'on molecular.\\

El formato SMILES es sencillo, f\'acil de entender y bastante peque\~no. Desgraciadamente no nos da informaci\'on sobre la mol\'ecula m\'as all\'a de sus \'atomos y los enlaces. No sabemos nada de la posici\'on de cada \'atomo, la geometr\'ia de la mol\'ecula, qu\'e carga tiene cada \'atomo, qu\'e regiones son nucleof\'ilicas o electrof\'ilicas, etc. Adem\'as, el problema m\'as grande de SMILES es que existen varias maneras de representar la misma mol\'ecula con diferentes SMILES!\\

\noindent \inlinecode{OC(=O)C(C)C1=CC=C(CC(C)C)C=C1} es tambi\'en un ibuprofeno!\\
\inlinecode{C1=C(CC(C)C)C=CC(C(C)C(O)=O)=C1} es tambi\'en un ibuprofeno!!\\
\inlinecode{C1=CC(C(C)C(O)=O)=CC=C1CC(C)C} es tambi\'en un ibuprofeno!!!\\

Es un poco problem\'atico tener varias maneras de reprensetar la misma mol\'ecula. Por esta raz\'on, IUPAC decidi\'o crear su propio formato que \emph{arreglaba} este problema.

\subsubsection{International Chemical Identifier - InChI}
Lo primero que haremos ser\'a transformar nuestro ibuprofeno SMILES a un ibuprofeno InChI. Esto lo vamos a hacer de la siguiente manera. En la l\'inea de comando vamos a escribir:

\begin{Code}
obabel -ismi ibuprofen.smi -oinchi -Oibuprofen.inchi -h -xw
\end{Code}

OpenBabel nos avisa que realiz\'o la conversi\'on con \'exito, pero ... qu\'e significa eso? Estudiemos un poco qu\'e es lo que hicimos. Llamamos a OpenBabel con \inlinecode{obabel}, indicamos el formato de entrada agregando \inlinecode{smi} a \inlinecode{-i}, indicamos el archivo de entrada \inlinecode{ibuprofen.smi}, especificamos el formato de salida agregando \inlinecode{inchi} a \inlinecode{-o}, indicamos el \emph{archivo} de salida agregando \inlinecode{ibuprofen.inchi} a \inlinecode{-O} y ... por el momento dej\'emoslo all\'i. Eso ya fue bastante informaci\'on.\\

Si nos damos cuenta, la sintaxis no es tan complicada:

\begin{Code}
obabel -iXXX NOMBRE.XXX -oYYY -ONOMBRE.YYY
\end{Code}

\begin{itemize}
\item \inlinecode{XXX} es el formato de la mol\'ecula que ya tenemos.
\item \inlinecode{NOMBRE} es el nombre del archivo en el que se halla nuestra mol\'ecula.
\item \inlinecode{YYY} es el formato en el que queremos nuestra mol\'ecula.
\end{itemize}

Lo que hab\'iamos agregado al final en el caso de la conversi\'on a formato InChI fue \inlinecode{-h -xw}. La primera bandera (\inlinecode{-h}) le dice a OpenBabel que este debe de asignarle hidr\'ogenos a la mol\'ecula. Si ponemos atenci\'on, estos no est\'an especificados en el SMILES. Por otra parte, la bandera \inlinecode{-xw} le dice a OpenBabel que ignore cualquier problema de estereoqu\'imica que pueda encontrar este al generar la mol\'ecula. En este momento, eso no importa tanto. Veamos pues, de qu\'e se trata un InChI.\\

En la l\'inea de comando, vamos a escribir \inlinecode{cat ibuprofen.inchi}. Esto nos mostrar\'a el contenido del archivo y all\'i podremos ver a qu\'e nos enfrentamos.

\begin{Code}
InChI=1S/C13H18O2/c1-9(2)8-11-4-6-12(7-5-11)10(3)13(14)15/h4-7,9-10H,8H2,1-3H3,(H,14,15)
\end{Code}

El formato InChI fue creado por IUPAC y significa \textbf{In}ternational \textbf{Ch}emical \textbf{I}dentifier. El formato es un poco m\'as complicado que SMILES, pero sigue el mismo principio de intentar representar una mol\'ecula en una sola l\'inea. La diferencia es que InChI intenta ir dando informaci\'on por capas. Veamos cada una:

\begin{enumerate}
\item \inlinecode{1S} es la capa que especifica que se trata de la versi\'on e\textbf{S}tandar \textbf{1} de InChI.
\item \inlinecode{C13H18O2} es la segunda capa. Si ponemos atenci\'on al detalle, esta es la \textbf{f\'ormula molecular}.
\item \inlinecode{c1-9(2)8-11-4-6-12(7-5-11)10(3)13(14)15} es la tercera capa. Esta especifica la conectividad de los \'atomos dentro de la mol\'ecula. Siempre comienza con una \inlinecode{c}. La \href{http://www.inchi-trust.org/technical-faq/#11.2}{numeraci\'on} de los \'atomos no es evidente.
\item \inlinecode{h4-7,9-10H,8H2,1-3H3,(H,14,15)} es la cuarta capa. En ella se halla la ubicaci\'on de los hidr\'ogenos en la mol\'ecula. Esta siempre comienza con una \inlinecode{h}. En este caso, se establece primero los \'atomos sobre los que se va a colocar el hidr\'ogeno \inlinecode{H} y luego se dice cu\'antos hidr\'ogenos han de colocarse en cada uno de los anteriores \'atomos.
\end{enumerate}

Existen otras capas dentro del formato InChI. Entre ellas hay capas para cargas, estereoqu\'imica, is\'otopos, hidr\'ogenos fijos, etc. El documento que describe todo esto de manera exhaustiva es el \href{http://www.inchi-trust.org/download/104/InChI_TechMan.pdf}{Manual T\'ecnico} de InChI. Solo si \emph{realmente} queremos trabajar con este formato es una buena idea revisarlo.\\

Fuera de eso, InChI se utiliza casi solo para revisar bases de datos en l\'inea\footnote{Tambi\'en se utiliza la Llave InChI o InChIKey, aunque esta es menos comprensible para el usuario. Esta la generamos agregando la bandera \inlinecode{-xK} a la conversi\'on en OpenBabel.}, lo podemos generar con OpenBabel y su uso en c\'alculos de propiedades moleculares es m\'inimo.

\subsubsection{XYZ}
Ahora, lo que haremos ser\'a estudiar otro tipo de formato de archivo. Por sus siglas, ya deber\'iamos tener una idea clara de que el tema central del formato ser\'an las coordenadas en 3 dimensiones. Veamos de generarlo con OpenBabel.

\begin{Code}
obabel -ismi ibuprofen.smi -oxyz -Oibuprofen.xyz -h --gen3D
\end{Code}

Esto pudo haber tomado un momento, pues le pedimos a OpenBabel que generara la estructura tridimensional del ibuprofeno por medio de la bandera \inlinecode{--gen3D}. Para estudiar nuestra mol\'ecula, haremos lo mismo que la vez anterior: escribiremos \inlinecode{cat ibuprofen.xyz}.\\

Tal como sospech\'abamos, se trata coordenadas 3D. El formato XYZ nos da, en su primera l\'inea, el n\'umero de \'atomos en la mol\'ecula. Luego, por fila, especifica la identidad del \'atomo, y sus coordenadas \textbf{X}, \textbf{Y} y \textbf{Z} en el espacio. Si ponemos atenci\'on, no especifica nada sobre enlaces! Este es el primer formato de archivo que no nos da informaci\'on de los enlaces ni siquiera de manera impl\'icita.\\

Solo como dato curioso, la l\'inea en blanco que hallamos entre el n\'umero de \'atomos en la mol\'ecula y los \'atomos con sus coordenadas es una l\'inea para comentarios. All\'i podr\'iamos escribir cualquier cosa que necesitemos.\\

El formato \href{http://openbabel.org/wiki/XYZ_(format)}{XYZ} es de aquellos que no siguen un est\'andar. Este se utiliza mucho para c\'alculos en mec\'anica cu\'antica o para representar resultados de din\'amicas moleculares, de repetir el mismo patr\'on que vimos varias veces dentro del mismo archivo pero con diferentes coordenadas, podemos ir estudiando \emph{movimiento} de mol\'eculas.

\subsubsection{MDL Mol - mol}
MOL fue uno de los primeros formatos en incluir m\'as informaci\'on sobre las mol\'eculas. Este intent\'o proveer suficiente informaci\'on para que construir una mol\'ecula no fuera un proceso complicado si deseamos hacerlo en 2 domensiones o en 3. Comencemos transformando nuestra mol\'ecula.

\begin{Code}
obabel -ismi ibuprofen.smi -omol -Oibuprofen.mol -h --gen3D
\end{Code}

Esta vez no vamos a visualizar nuestra mol\'ecula con \inlinecode{cat}, sino que vamos a abrirla en un editor de texto con interfaz gr\'afica. Para ello vamos a escribir \inlinecode{pluma ibuprofen.mol}. Lo primero que vamos a notar es que es bastante informaci\'on la que nos da este formato. Vayamos poco a poco.\\

\begin{enumerate}
\item La primera l\'inea est\'a reservada para el nombre de la mol\'ecula. Como jam\'as le asignamos un nombre (nada adem\'as del nombre del archivo), esta l\'inea aparece en blanco. Si lo deseamos, podemos escribir \textit{ibuprofeno} en la primera l\'inea y guardar el archivo; esto no deber\'ia dar ning\'un problema.
\item La segunda l\'inea nos da informaci\'on sobre el programa utilizado para generar esa mol\'ecula y la fecha en que esto fue realizado. Tambi\'en nos da m\'as informaci\'on, pero nada a lo que valga la pena ponerle atenci\'on para nuestros fines.
\item La tercerla l\'inea sirve para comentarios. Aqu\'i podemos colocar observaciones o comentarios sobre la mol\'ecula que estamos trabajando.
\item La cuarta l\'inea consta de muchos n\'umeros. De ellos nos interesan los primeros dos y el \'ultimo. Los primeros dos especifican el n\'umero de \'atomos y enlaces\footnote{En este caso, pensemos en los enlaces como conecciones. El formato MOL no distingue entre enlaces simples dobles o triples, as\'i que solo se habla de que en la mol\'ecula hay X n\'umero de conecciones.} que hay en la mol\'ecula. El \'ultimo n\'umero nos habla del est\'andar que se ha utilizado para construir este archivo: V2000.
\item De la quinta l\'inea en adelante vemos una especie de matriz de n\'umeros. No entremos en p\'anico, lo que nos dice cada l\'inea es sencillo. Los primeros 3 n\'umeros son las coordenadas de un \'atomo en X, Y y Z como en los archivos XYZ. Lo siguiente es la identidad del \'atomo: su s\'imbolo. Luego vienen una serie de ceros que generalmente no se utilizan.
\item Despu\'es de varias l\'ineas con n\'umeros con decimales, aparece un bloque de n\'umeros que comienza con enteros. Estos nos dan informaci\'on sobre los enlaces. El primer entero representa el primer \'atomo de donde sale el enlace. El segundo entero representa al \'atomo a donde va el enlace. El tercer entero nos dice qu\'e tipo de enlace es: 1 = simple, 2 = doble, 3 = triple.
\item Finalmente hallamos \inlinecode{M END}. Aqu\'i nos est\'an diciendo que el archivo tiene su fin.
\end{enumerate}

Como vemos, el formato MOL es bastante m\'as completo que los que hab\'iamos visto antes. Nos permite saber de qu\'e \'atomos se compone nuestra mol\'ecula, qu\'e enlaces hay y d\'onde est\'an, las coordenadas de cada \'atomo, etc. Sin embargo, no nos dice nada m\'as.\\

El formato MOL fue el precursor de muchos otros formatos m\'as modernos que veremos a continuaci\'on. Este, a pesar de que ya no se utiliza tanto gracias a MOL2, CML y PDB, es reconocido casi que por cualquier software de qu\'imica. Por eso es importante tomarlo en cuenta.

\subsubsection{MDL Structure-Data File - SDF}
Ya que entendimos c\'omo se trabaja con MOL, vamos a ver el formato SDF. El SDF fue dise\~nado como una extensi\'on del formato MOL para poder incluir m\'as propiedades de una mol\'ecula y, adem\'as, m\'as mol\'eculas en el mismo archivo. El comando para convertir el SMILES en SDF es el siguiente.

\begin{Code}
obabel -ismi ibuprofen.smi -osdf -Oibuprofen.sdf -h --gen3D
\end{Code}

Al abrirlo con Pluma \inlinecode{pluma ibuprofen.sdf} notamos que este es igual a MOL. Es exactamente id\'entico, excepto por la \'ultima l\'ina. La l\'inea con los 4 signos de d\'olar \inlinecode{\$\$\$\$} especifica que en ese punto acab\'o una mol\'ecula y a partir de all\'i puede comenzar otra. Esta \'ultima quiz\'a no es la mejor caracter\'istica de SDF. Intentemos hacer un cambio para mostrar mejor la primera. Cerremos el archivo y vamos a volver a correr OpenBabel, pero esta vez agregaremos algo.

\begin{Code}
obabel -ismi ibuprofen.smi -osdf -Oibuprofen.sdf -h --gen3D --property LD50 1255mg/kg
\end{Code}

Ahora volvamos a abrir el archivo con Pluma, vayamos al final del mismo y observemos detenidamente. Qu\'e acabamos de hacer? \emph{Esta} es la caracter\'istica m\'as interesante de SDF: su capacidad de almacenar otras propiedades moleculares.\\

EL formato \href{http://molmatinf.com/whynotmolsdf.html}{SDF} se utiliza mucho para trabajar con conjuntos de mol\'eculas y sus propiedades. El hecho de poder almacenar cualquier informaci\'on arbitrariamente lo hace un formato atractivo para quimioinform\'atica.

\subsubsection{Tripos MOL2 Format - mol2}
A continuaci\'on vamos a estudiar uno de los formatos m\'as completos para trabajar mol\'eculas. Este formato fue una mejora al formato MOL, pero este fue creado por una empresa llamada Tripos (hoy \href{https://www.certara.com/}{Certara}) para su paquete de software \href{https://www.certara.com/software/molecular-modeling-and-simulation/sybyl-x-suite/}{Sybyl}. Comencemos creando el archivo mol2.

\begin{Code}
obabel -ismi ibuprofen.smi -omol2 -Oibuprofen.mol2 -h --gen3D
\end{Code}

Ya nos vamos acostumbrando a convertir mol\'eculas con OpenBabel, y esta vez notamos que la \'unica diferencia con el comando anterior es que solo agregamos un \inlinecode{2} en algunos lugares estrat\'egicos. Vamos a revisar el contenido del archivo MOL2 con Pluma: \inlinecode{pluma ibuprofen.mol2}.\\

A primera vista se parece un poco al formato MOL, pero si ponemos atenci\'on, el formato MOL2 utiliza ciertas palabras clave para ir delimitando cada segmento del archivo. Este comienza con \inlinecode{@<TRIPOS>MOLECULE}. Despu\'es de esto, la primera l\'inea queda reservada para el nombre de la mol\'ecula. Este lo podemos editar nosotros inmediatamente si as\'i lo deseamos. Posteriormente viene el conteo de cu\'antos \'atomos, cu\'antos enlaces, cu\'antas subestructuras, cu\'antas caracter\'isticas y cu\'antos sets o conjuntos hay en la mol\'ecula. A nosotros nos interesan los primeros 2. En la siguiente l\'inea hallamos el tipo de mol\'ecula con el que tratamos. Esta generalmente es \inlinecode{SMALL}. Posteriormente viene una l\'inea en donde se especifica el tipo de cargas parciales que se le asignaron a cada \'atomo. Finalmente, como en los formatos anteriores, viene una l\'inea en blanco reservada para comentarios.\\

Esa fue solo la primera parte. Con eso ya nos damos cuenta que MOL2 tiene un poco m\'as de informaci\'on que el formato MOL. Ahora vamos a proceder con la parte de \inlinecode{@<TRIPOS>ATOMS}. Cada l\'inea de este segmento consta de las siguientes columnas: un correlativo que se le asigna a cada \'atomo, el s\'imbolo del \'atomo, las coordenadas en X, Y y Z del \'atomo, la hibridaci\'on del \'atomo (C.1 = carbono sp$^1$, C.3 = carbono sp$^3$, C.ar = carbono arom\'atico, etc.), luego est\'a el n\'umero de subestructura al que pertenece este \'atomo\footnote{Un archivo MOL2 es capaz de almacenar varias subestructuras a partir de una estructura molecular. La manera en que se distinguen los \'atomos de cada una es por este n\'umero.}, el nombre de la subestructura al que pertenece el \'atomo y la carga parcial que tiene ese \'atomo.\\

Como vemos, la parte anterior tambi\'en es m\'as completa que en el caso de MOL. Esta cuenta con informaci\'on de hibridaci\'on y carga parcial de cada \'atomo. Finalmente hallamos la secci\'on \inlinecode{@<TRIPOS>BONDS}. Esta se parece mucho a la manera en que MOL codifica sus enlaces. En cada l\'inea hallamos el correlativo del enlace, el \'atomo del que sale el enlace, el \'atomo al que llega el enlace y al final queda el tipo de enlace.\\

El formato \href{https://app.box.com/s/kyim989nneeg7y4yhjrtdvbkjjl36ecg}{MOL2 de Tripos} se ha utilizado mucho por la riqueza de informaci\'on que ofrece frente a los antiguos formatos. Sin embargo, este todav\'ia queda corto en algunas cosas. Este es muy utilizado en dise\~no de f\'armacos, materiales, quimioinform\'atica y simplemente para almacenar mol\'eculas.

\subsubsection{Chemical Markup Language - CML}
Otra opci\'on m\'as moderna para guardar una mol\'ecula es utilizar el formato CML. Este es realmente un lenguaje markup, as\'i como HTML y \LaTeX, aunque se parece m\'as al primero. La idea de CML es guardar la misma informaci\'on que los otros formatos, pero utilizando \textit{tags}. Convirtamos nuestra mol\'ecula y veamos c\'omo es que se ve.

\begin{Code}
obabel -ismi ibuprofen.smi -ocml -Oibuprofen.cml -h --gen3D
\end{Code}

Al abrir nuestro archivo con Pluma, vamos a notar que este parece un segmento de p\'agina web. Es m\'as! Nuestro archivo comienza con \inlinecode{<?xml version="1.0"\ \hspace*{-2mm}?>}, lo que significa que este es realmente un archivo XML\footnote{Un archivo XML es, por as\'i decirlo, una versi\'on extendida de HTML. Este tipo de archivo ha sido adaptado a muchas necesidades recientes y es muy utilizado por su caracter de base de datos noSQL. Su uso inmediato est\'a en los documentos de Microsoft Word o Microsoft Excel; la \textbf{x} al final de la extensi\'on del documento se refiere a que est\'an basados en XML.} adaptado a qu\'imica. Despu\'es de eso viene lo interesante.\\

El archivo contin\'ua con el tag \inlinecode{<molecule xmlns="http://www.xml-cml.org/schema"\ \hspace*{-2mm}>}, el cual es \emph{cerrado} al final con \inlinecode{</molecule>}. Todo lo que vaya dentro de este tag es parte de una mol\'ecula. Aqu\'i lo que se hizo fue delimitar el espacio de una mol\'ecula de igual manera en que hac\'iamos con \inlinecode{@<TRIPOS>MOLECULE} en MOL2. De hecho, mucha de la sintaxis de CML se parece o tiene sus bases en MOL2.\\

Luego continuamos con 2 tags m\'as. Est\'a \inlinecode{<atomArray>} que denota el arreglo de \'atomos dentro de la mol\'ecula y \inlinecode{<bondArray>} que denota los enlaces dentro de la mol\'ecula. Al observar cuidadosamente, notamos que los \'atomos tienen la misma informaci\'on que en MOL, SDF o MOL2: un identificador, el s\'imbolo y sus coordenadas en X, Y y Z. En el caso de los enlaces, se cumple la misma idea: un identificador, \'atomo de donde sale el enlace, \'atomo a donde llega el enlace y qu\'e tipo de enlace es.\\

Si bien esto se vio muy sencillo, CML es capaz de almacenar informaci\'on sobre propiedades moleculares al igual que SDF. Es uno de los formatos \href{https://jcheminf.springeropen.com/articles/10.1186/1758-2946-3-44}{m\'as nuevos} en qu\'imica y se desea establecer como el \href{http://www.xml-cml.org/}{est\'andar}, pues es capaz de hacer todo lo que todos los anteriores y de mejor manera; m\'as ordenada. CML es utilizado para guardar mol\'eculas y crear bases de datos con ellas. Es superior a MOL2, pero su uso todav\'ia no es tan popular.

\subsubsection{Protein Data Bank - PDB}
Uno de los \'ultimos formatos que vamos a estudiar ser\'a el PDB. Sus siglas fueron propuestas porque es de los pocos formatos de archivo en los que se almacenan mol\'eculas tan complejas como las prote\'inas. Este consta de muchas partes! M\'as que cualquier otro formato de los que hemos visto. Convirtamos nuestro ibuprofeno a este formato y analicemos lo que contiene.

\begin{Code}
obabel -ismi ibuprofen.smi -opdb -Oibuprofen.pdb -h --gen3D
\end{Code}

Al abrir nuestro documento con Pluma, nuestro editor de texto, hallamos que si bien este formato ya nos parece algo familiar, es un tanto distinto. En este se comienza con un indicador \inlinecode{COMPND}, que nos da el nombre de la mol\'ecula que estamos tratando. Como no hemos especificado un nombre, la mol\'ecula queda como \inlinecode{UNNAMED}.\\

Posteriormente, seguimos con \inlinecode{HETATM} y con \inlinecode{CONECT}. Es claro que en el primer caso se trata de los \'atomos y el segundo de los enlaces. En el primer caso, cada columna representa lo siguiente: el correlativo de cada \'atomo, el nombre del \'atomo, el nombre del \emph{residuo} al que pertenece, el n\'umero del residuo al que pertenece, las coordenadas en X, Y y Z, otro par de datos que no son de mucha reelevancia ahora y finalmente el s\'imbolo del \'atomo.\\

En el caso de los enlaces es un poco distinto. Cada \'atomo tiene informaci\'on de los otros \'atomos a los que se enlaza. Por ende, la primera columna es la del n\'umero de \'atomo del que \emph{sale} el enlace. Las otras columnas son los \'atomos que \emph{reciben}\footnote{Se est\'a utilizando la idea de que los enlaces van de un \'atomo a otro como convenci\'on y para hacer m\'as comprensible la manera en que est\'an codificados los archivos.} el enlace. Al final de esta secci\'on tenemos un indicador \inlinecode{MASTER} que nos da informaci\'on general del archivo y, luego \inlinecode{END} en donde todo termina.\\

Eso es todo? No exactamente. Para esta mol\'ecula este tipo de archivo es sencillo, pues no tiene ninguna otra caracter\'istica especial. Sin embargo, si deseamos entender qu\'e tan complejo puede llegar a ser uno de estos archivos, solo debemos revisar \href{https://files.rcsb.org/view/5F19.pdb}{\textbf{5F19}}. \emph{Esa} estructura s\'i se ve complicada! Pero veremos en un momento que realmente no lo es; solo no debemos enfocarnos en cada detalle, sino verla de una manera m\'as general.\\

Los archivos \href{http://www.wwpdb.org/documentation/file-format-content/format33/v3.3.html}{PDB} son una fuente de informaci\'on muy grande cuando ya se trabaja con mol\'eculas igual de grandes. Ellos son los preferidos en el caso de prote\'inas, pues codifican a muchos amino\'acidos, su secuencia y la posici\'on de sus \'atomos en tres dimensiones, adem\'as de mucha informaci\'on sobre los autores, la publicaci\'on, etc.

\subsection{BLAST}
El algoritmo BLAST (\textbf{B}asic \textbf{L}ocal \textbf{A}lignment \textbf{S}earch \textbf{T}ool) es el resultado de varios intentos de comparar secuencias de ADN y de amino\'acidos de manera r\'apida y eficiente. Este es utilizado para buscar secuencias que se parezcan a un segmento dado. En otras palabras, nosotros vamos a tener un peque\~no segmento de una secuencia y BLAST buscar\'a cu\'al de todas las secuencias en su base de datos es la que m\'as se asemeja a ella y en cu\'anto. Vamos a verlo a detalle con un ejemplo.\\

Para hallar secuencias que se parezcan a nuestro segmento, BLAST comienza descartando las regiones de baja complejidad de cada secuencia. Estas son las regiones en las que algunas pocas unidades se presentan de maneras repetitivas. En nuestro caso vamos a obviar esa parte, porque no vamos a trabajar con secuencias tan complicadas.\\

El coraz\'on del algoritmo es una matriz\footnote{Revisar la matriz \href{https://www.ncbi.nlm.nih.gov/Class/FieldGuide/BLOSUM62.txt}{BLOSUM62}, \href{https://www.ncbi.nlm.nih.gov/pmc/articles/PMC50453/pdf/pnas01096-0363.pdf}{qu\'e compara} y su relaci\'on con el algoritmo BLAST.} que nos ayuda a interpretar la prioridad que le vamos a asignar a cada amino\'acido o cada base nitrogenada. Para hacer el ejemplo sencillo, vamos a trabajar con ADN. En ese caso, vamos a dise\~nar nuestra matriz en donde comparamos una secuencia de referencia con una secuencia de prueba$^{*}$ de la siguiente forma:

\begin{equation*}
\begin{matrix}
 & \vert & A^{*} & C^{*} & G^{*} & T^{*}\\
\hline
A & \vert & \textbf{1} & -1 & -1 & -1\\
C & \vert & -1 & \textbf{1} & -1 & -1\\
G & \vert & -1 & -1 & \textbf{1} & -1\\
T & \vert & -1 & -1 & -1 & \textbf{1}
\end{matrix}
\end{equation*}

Esta peque\~na matriz nos dice que si las bases nitrogenadas son iguales en ambas secuencias que estamos comparando, entonces el valor de la comparaci\'on es 1, si no, es de -1. La idea es entonces ir comparando las bases nitrogendas e ir sumando el resultado de las comparaciones: la primera con la primera, la segunda con la segunda, etc. Si el resultado de esa suma supera cierto umbral, se toma como que las cadenas de ADN son similares. Si no lo supera, la descarta. Sin embargo, hacer eso con cada base ser\'ia un proceso muy tardado.\\

Para resolver este problema, utilizamos otra estrategia: dividimos nuestra secuencia en \emph{palabras} de 3 o 4 letras (al comparar ADN las palabras son de 11 letras generalmente). Eesto significa que, si tenemos una secuencia $\underset{0}{G} \underset{1}{A} \underset{2}{T} \underset{3}{G} \underset{4}{C} \underset{5}{A}$, las palabras que 4 letras que podr\'iamos formar son: $\underset{0}{G} \underset{1}{A} \underset{2}{T} \underset{3}{G}$, $\underset{1}{A} \underset{2}{T} \underset{3}{G} \underset{4}{C}$ y $\underset{2}{T} \underset{3}{G} \underset{4}{C} \underset{5}{A}$. Ahora que ya tenemos dividida la cadena en palabras, podemos proceder a ordenar y ver qu\'e tanto se repiten las palabras. Esta es una de las diferencias entre el algoritmo BLAST y su antecesor FASTA. En el caso del \'ultimo, todas las palabras son importantes y se revisan. En el caso de BLAST, solo toma en cuenta las palabras m\'as importantes seg\'un la cantidad de veces que aparece en la secuencia y el \emph{score} obtenido de compararse con la matriz de la que hablamos anteriormente. Veamos esto por pasos.\\

Primero comenzamos con la parte m\'as sencilla: Revisamos la cantidad de veces que aparece la palabra en cada secuencia y las anotamos. Luego ordenamos las palabras por la cantidad de veces que aparecieron. Finalmente, revisamos si las palabras de la secuencia de prueba aparecen en la secuencia de referencia.\\

Entonces, en resumen, vamos a dividir la secuencia en palabras. Luego vamos a ver qu\'e tanto se repiten las palabras que hallamos y a hacer una lista de ellas. Las ordenamos y comparamos las palabras de la secuencia de prueba con la de referencia. El paso que determina la diferencia entre BLAST y FASTA va entre el ordenado y la comparaci\'on. Lo que haremos es escoger solo las palabras que tengan muchas apariciones. Cu\'anto es \emph{muchas}? Un umbral que nosotros decidamos. Esto va a depender mucho de la longitud de la secuencia. Podr\'iamos tener un valor relativo al tama\~no de la secuencia, pero en este caso lo vamos a definir nosotros como un valor fijo para mantener las cosas simples.\\

Una vez hecho todo esto, toca realmente comparar las dos secuencias. Para ello comenzamos a buscar palabra por palabra de la secuencia de prueba para compararla con la secuencia de referencia. Al comparar una palabra, buscamos la palabra en la secuencia de referencia, la encontramos y luego vamos revisando, hacia la derecha y la izquierda, las letras alrededor de la palabra en las secuencias. Al ir haciendo esto, vamos comparando utilizando la matriz que definimos al principio. La idea es seguir creciendo hacia los lados mientras el \emph{score} sea m\'as alto que cierto umbral. Si el \emph{score} baja, guardamos la regi\'on que encaj\'o con un \emph{score} mayor al umbral todav\'ia, y regresamos a seguir revisando con la siguiente palabra. Al final, vamos a tener un listado con todas las regiones de las secuencias que se parecen! Ahora es donde se pone interesante.\\

De listado que obtuvimos, vamos a escoger solo los mejores resultados. Es decir, los segmentos que tengan el \emph{score} m\'as alto. La idea es que podamos visualizar estos resultados (en nuestro caso). En el caso de los servidores en internet que utilizan BLAST para buscar en grandes bases de datos, solo se basan en el \emph{score} m\'as alto para revisar cu\'al de todas las secuencias en la base de datos es la m\'as parecida a nuestra secuencia de prueba. Al final lo que obtendr\'iamos de una b\'usqueda as\'i es la secuencia que m\'as se parece a la nuestra. Pero en nuestro caso, solo deseamos verlas una al lado de la otra. Por eso, vamos a dise\~nar una peque\~na funci\'on para poder visualizar el resultado.\\

Este es, entonces, un buen momento para revisar el documento \emph{BLAST (attempt).ipynb} y repasar todo lo que hemos dicho ac\'a. Luego, vamos a probar con las secuencias que se nos ocurran para ver c\'omo reacciona el algoritmo. Cuando logremos explicar, en nuestras palabras, lo que hace cada funci\'on en el algoritmo y c\'omo es que todo se integra, podemos pasar a la siguiente secci\'on.

\subsection{An\'alisis de Secuencias}
Una parte importante de la bioinform\'atica implica analizar pol\'imeros como prote\'inas o enzimas. Esta vez lo vamos a hacer de manera visual y utilizando UCSF Chimera. Para ello vamos a necesitar 1 enzima, la cual vamos a buscar y descargar en \href{http://www.rcsb.org/pdb/home/home.do}{RCSB PDB}. En particular, queremos la prote\'ina con c\'odigo: \textbf{1PXX}. Vamos a descargar el archivo con extensi\'on \emph{.pdb} simple y lo vamos a guardar en nuestra carpeta de datos.\\

A continuaci\'on vamos a abrir UCSF Chimera y vamos a abrir la prote\'ina. Al abrirla, observ\'emosla, veamos qu\'e tiene de especial, algo que nos llame la atenci\'on, si identificamos un sitio activo, etc. Cuando ya hayamos revisado un poco, vamos a ir a \emph{Tools}, \emph{Sequence} y \emph{BLAST Protein}. All\'i vamos a escoger la secuencia \textbf{1PXX}, cadena \textbf{A}, y vamos a hacer click en \emph{Apply}. As\'i vamos a ver c\'omo es que BLAST va hallando todas las prote\'inas que se le parecen a esta secuencia. Es importante notar que entre los resultados va a aparecer nuestra prote\'ina \textbf{1PXX} y otra prote\'ina con c\'odigo \textbf{4FM5}, las cuales vamos a utilizar en un momento.\\

Ahora que ya vimos c\'omo funciona BLAST en la vida real, vamos a ver algunas propiedades de nuestra prote\'ina \textbf{1PXX} y la \textbf{4FM5} hallada con BLAST. Esto es, qu\'e tanto se parecen entre ellas. Primero vamos a escoger las prote\'inas \textbf{1PXX} y \textbf{4FM5} halladas con BLAST, y luego vamos ir a \emph{Load Structure}. En unos segundos vamos a ver c\'omo es que las nuevas prote\'inas aparecen superpuestas de manera casi perfecta. Lo que no se ve muy bien es nuestra prote\'ina original. Para ello, la vamos a quitar de la pantalla. Nos vamos a \emph{Favorites}, \emph{Model Panel}, seleccionamos nuestra prote\'ina, y presionamos \emph{close} de entre las opciones que se nos presentan. Ahora, con el af\'an de centrar nuestros dos nuevos modelos, vamos a \emph{Actions}, y luego a \emph{Focus}. Ahora estamos listos para comenzar el an\'alisis.\\

Cerramos todas las ventanas de di\'alogo que ten\'iamos abiertas y vamos nuevamente a \emph{Tools}, \emph{Sequence} y esta vez pasamos a \emph{Sequence}. All\'i seleccionamos la cadena \textbf{A} de la prote\'ina \textbf{1PXX} y hacemos click en \emph{OK}. A continuaci\'on nos aparecer\'a una ventana con la secuencia aminoac\'idica completa de la prote\'ina que escogimos. Hay algunas regiones, sin embargo, que est\'an en cajas con diferentes colores. Qu\'e pasar\'a si hacemos click en ellas? O mejor a\'un, qu\'e significar\'an que tengan diferentes colores? Intent\'emoslo y veamos qu\'e descubrimos. Como un tip, ir a \emph{Select}, \emph{Clear selection} puede servirnos.\\

Continuando, una cosa que puede llamar nuestra atenci\'on es comparar qu\'e tanto se parecen las dos prote\'inas en su secuencia aminoac\'idica. Se podr\'a hacer esto? En la ventana donde tenemos la secuencia de amino\'acidos, vamos a ir a \emph{Edit}, luego a \emph{Add sequence ...}, y ya en la ventana vamos a escoger la pesta\~na \emph{From structure}. All\'i vamos a escoger la secuencia \textbf{4FM5} cadena \textbf{A}, y haremos click en \emph{OK}. Despu\'es de unos segundos, habremos notado que ahora tenemos las dos secuencias una sobre la otra y separadas a modo de hacer m\'as comprensible el an\'alisis entre las dos. Resulta interesante muchas veces notar que las cajas de colores no coinciden muchas veces, a pesar de que la secuencia de amino\'acidos es similar. Esto se debe a algunas diferencias en la posici\'on de los \'atomos de las prote\'inas; en algunos casos forman una estructura especial, y en otros no.\\

Finalmente, vamos a determinar si realmente la identidad de los amino\'acidos de ambas secuencias es la misma. En otras palabras, vamos a ver qu\'e tanto se parecen las dos secuencias. Para ello hacemos click en \emph{Info} y en \emph{Percent Identity}. Seleccionamos las dos cadenas que deseamos comparar y hacemos click en \emph{Apply} para ver el porcentaje en el que se parecen ambas cadenas. Esta cifra aparecer\'a en la esquina inferior izquierda de la ventana donde vemos las secuencias de amino\'acidos. Qu\'e sucedi\'o con el n\'umero que obtuvimos? Nos parece satisfactorio el resultado obtenido? Y para dejar una inquietud: qu\'e pasar\'ia si, escogiendo \emph{otra} prote\'ina de la lista de resultados de BLAST, hacemos lo mismo? Intent\'emoslo y veamos qu\'e sucede. Posteriormente, comentemos con nuestro compa\~nero a ver qu\'e opini\'on resulta teniendo despu\'es de realizar esta prueba. De qu\'e nos sirve saber el porcentaje de identidad entre prote\'inas?\\

La cantidad de herramientas que nos da \textit{Chimera} para seguir trabajando es inmensa. Exploremos qu\'e m\'as es lo que podemos ir haciendo con este programa. Generalmente lo utilizamos para eliminar residuos o agua que ha quedado en la estructura 3D de las prote\'inas. Vamos a seguir en este ambiente, pero vamos a pasar a otro tema para continuar.

\subsection{Docking}
El docking molecular es una t\'ecnica que permite la simulaci\'on del acoplamiento de una mol\'ecula con otra, y el c\'alculo de la energ\'ia de interacci\'on entre ambas. Si bien es sencilla y relativamente r\'apida, no es la m\'as efectiva para hallar resultados contundentes en investigaci\'on. Se utiliza m\'as como una t\'ecnica exploratoria para revisar si existe la posibilidad de un acoplamiento, o para determinar un par\'ametro energ\'etico en un tamizaje molecular virtual. En nuestro caso vamos a tratar de realizar un docking de un analg\'esico en nuestra prote\'ina \textbf{1PXX}, que por cierto es la enzima ciclooxigenasa tipo 2.\\

\subsubsection{Utilizando una Interfaz Gr\'afica}

Para comenzar con esto, vamos a cerrar y volver a abrir \textit{UCSF Chimera} y vamos a abrir exclusivamente nuestra prote\'ina \textbf{1PXX}. Adem\'as de esto, vamos a abrir nuestra prote\'ina con un editor de texto para ver qu\'e informaci\'on nos da sobre la prote\'ina y sobre el sitio activo de la misma. Vamos a ir paso a paso. Solo viendo nuestro documento \emph{pdb} en el editor de texto, vamos a plantearnos las siguientes preguntas:

\begin{itemize}
\item Qu\'e prote\'ina es esta realmente y qu\'e regula?
\item Qu\'e inhibidor tiene en su estructura?
\item De qu\'e organismo es esta prote\'ina?
\item Se puede saber qui\'en realiz\'o el estudio en donde se elucid\'o esta estructura?
\end{itemize}

Cuando ya tengamos una respuesta para esto, podremos continuar. Siempre intentemos comentar nuestros hallazgos con alguien m\'as y buscar qu\'e m\'as podemos hallar entre toda la informaci\'on que se nos presenta.\\

Ahora nos toca revisar detenidamente a la prote\'ina con Chimera. Una de las primeras cosas que probablemente nos van a interesar son los \emph{residuos} que se hallan cerca, o dentro de la mol\'ecula. Para ello, vamos a irlos revisando uno a uno. Vamos a ir a \emph{Select}, luego a \emph{Residue}, y en la categor\'ia de \emph{all nonstandard} vamos a hallar a todas aquellas mol\'eculas que no son una secuencia de amino\'acidos. De estas nos van a interesar HOH y DIF.\\

Si hacemos click en HOH, vamos a seleccionar todas las mol\'eculas de \emph{agua} que se hallan en la estructura. Estas no nos sirven generalmente y aparecen como producto de haber determinado la estructura de la prote\'ina con difracci\'on de rayos X. En este caso no las vamos a eliminar.\\

Si tenemos duda sobre los dem\'as residuos, podemos irlos seleccionando para verlos mejor e ir identificando cada uno. Si eso no nos interesa, podemos dejarlo con que BOG es b-octilgluc\'osido, HEM es un grupo hemo, y NAG es una N-acetil-D-glucosamina. El \'unico grupo que queda, que ser\'a el que nos interesa, es el grupo DIF. Pero claro, si leimos bien el contenido del documento \emph{pdb}, sabemos de qu\'e se trata.\\

Ahora que ya tenemos una mejor idea sobre la prote\'ina, vamos a identificar su sitio activo. Para ello necesit\'abamos saber que DIF est\'a ya en \'el. Lo que nos queda es definir \emph{ese} espacio como el sitio y remover a DIF para poder colocar algo m\'as all\'i adentro y evaluar la energ\'ia de ese cambio. Primero, debemos identificar la cadena \textbf{A} de la prote\'ina. Para ello solo sabremos que seleccionarla es una tarea f\'acil. Quedar\'a en nosotros averiguar c\'omo identificarla. Una vez ya sepamos cu\'al es la cadena \textbf{A}, vamos a seleccionar a DIF y a rotar la prote\'ina para poder ver bien el sitio activo en el que se encuentra. Cuando ya tengamos identificado el lugar, vamos a abrir otra mol\'ecula con Chimera: el paracetamol. Una vez abierta, vamos a dirigirnos a \emph{Tools}, luego a \emph{Surface/Binding analysis}, y finalmente a \emph{AutoDock Vina}. Esto nos deber\'ia haber llevado a una ventana con una serie de opciones. Ahora vamos a entender qu\'e significa cada una.\\

La primera opci\'on, \emph{Output file}, nos ofrece un lugar para crear un archivo con la configuraci\'on del docking que deseamos hacer. Generalmente es una buena idea colocar nuestros archivos en lugares especiales para no perderlos o confundirlos despu\'es. Luego est\'a el receptor que deseamos utilizar. En este caso este ser\'a la prote\'ina \textbf{1PXX}. Para escoger el ligando, escogemos la mol\'ecula de paracetamol que hab\'iamos abierto hace uno momento. Ahora es donde se vuelve un poco m\'as complicado.\\

El sitio activo de la prote\'ina es un lugar amorfo que realmente no conocemos. Lo \'unico que podemos asumir es que si DIF est\'a en \'el, la regi\'on alrededor de DIF es el sitio. Para ello vamos a intentar hacer una caja imaginaria, la cual comprenda al sitio activo en ella. Por eso necesitaremos coordenadas para centrar la caja, adem\'as de las dimensiones de la misma. Este proceso es generalmente complicado, puesto que se debe de ir moviendo la caja hasta hallar el lugar adecuado. En este caso nos ahorraron eso dici\'endonos que el centro de la caja est\'a en 27, 25, 15, y que las dimensiones de la caja son de 15, 15 y 15. Al ingresar estos datos en nuestra ventana, veremos la caja aparecer comprendiendo la regi\'on alrededor de donde se halla DIF.\\

Ahora ya tenemos al sitio activo comprendido en la caja, pero para poder colocar algo en \'el, necesitamos quitar a DIF de all\'i. Sin cerrar la ventana de AutoDock Vina, vamos a seleccionar a DIF nuevamente, y esta vez vamos a ir a \emph{Favorites}, \emph{Command Line}, en el campo que nos aparece en la parte inferior de la ventana escribiremos \inlinecode{delete selected} y presionaremos enter. Ahora ya hemos quitado a DIF. Para continuar vamos a volver a la ventana de AutoDock Vina y vamos a revisar la parte de \emph{Receptor options}. Estas son f\'aciles de entender. En nuestro caso vamos a configurarlas como \emph{true}, \emph{true}, \emph{false}, \emph{true}, \emph{false}, \emph{false}. Discutamos con nuestro compa\~nero de al lado por qu\'e creemos que estas opciones son las m\'as convenientes y qu\'e implica cambiar alguna de ellas. Despu\'es continuaremos con la parte del ligando.\\

La parte del ligando (\emph{Ligand options}) es relativamente f\'acil tambi\'en. En esta hay dos opciones que pondremos la en \emph{true} y \emph{false}. Como detalle, solo diremos que es muy conveniente que el ligando est\'e bien descrito para que, tanto por efectos est\'ericos como electrost\'aticos, el c\'alculo del mismo est\'e hecho de la mejor manera posible. Luego tenemos la parte de \emph{Advanced options}. Aqu\'i se nos piden 3 datos:

\begin{itemize}
\item El n\'umero de \textit{modos} de acoplamiento. Esto es el n\'umero de conformaciones diferentes que deseamos obtener como resultado final. Generalmente el programa sugiere 10, y esta vez no vamos a cambiar esa cifra.
\item Qu\'e tan exhaustiva debe de ser la b\'usqueda. En la documentaci\'on de AutoDock Vina se dice que un valor de 8 es suficiente, aunque podemos utilizar valores m\'as grandes (implicar\'an una b\'usqueda m\'as exhaustiva a un alto costo de tiempo) o m\'as peque\~nos (implican un menor tiempo de b\'usqueda, pero es probable que los resultados no sean los mejores).
\item La m\'axima diferencia de energ\'ia solo le dice al programa que deseamos resultados que no fluct\'uen m\'as de ese n\'umero de kcal/mol. Lo recomendable es una diferencia de 3 nada m\'as.
\end{itemize}

En resumen, lo que estamos haciendo con esto es como si busc\'aramos comprar una botella de agua al menor precio posible. Entonces le estamos diciendo a nuestro programa que deseamos que encuentre solo 10 tiendas en donde vendan agua pura al menor precio. Que busque de puerta en puerta (sin tocar en las ventanas o portones [exhaustivo], y sin ignorar las puertas de alg\'un tipo [poco efectivo]). Y que deseamos que nos muestre solo aquellas tiendas en donde el precio del agua no sea m\'as caro que 3 centavos que el precio m\'as bajo hallado. Haber definido una caja para el sitio activo es como haberle dicho al programa que solo puede buscar en todas las tiendas dentro de la ciudad, y no afuera.\\

Finalmente llegamos a \emph{Executable location}. Aqu\'i vamos a escoger la segunda opci\'on y vamos a colocar la ruta a AutoDock Vina. Si estamos en linux e instalamos todo de la forma usual, la ruta deber\'ia de ser \inlinecode{/usr/bin/vina} Para finalizar, hacemos click en OK y esperamos unos minutos. En este tiempo, vamos a explicar qu\'e es lo que est\'a sucediendo.\\

AutoDock busca coordenadas y conformaciones con un algoritmo gen\'etico\footnote{Otros programas para realizar docking tambi\'en utilizan algoritmos de anillamiento simulado, variaciones del algoritmo gen\'etico u otros para realizar lo mismo.} y eval\'ua la energ\'ia del complejo formado utilizando una funci\'on especial. Si recordamos bien la Sesi\'on 6, el algoritmo gen\'etico halla resultados de manera relativamente efectiva, pero a\'un as\'i tomar\'a un rato. AutoDock Vina no cuenta con una interfaz gr\'afica dedicada. Este programa se opera realmente desde una l\'inea de comando! Lo que est\'a haciendo Chimera es darnos una ayuda para preparar nuestras mol\'eculas y construir algo que llamamos un \emph{archivo de configuraci\'on}. Esto significa que podr\'iamos prescindir de Chimera, pero tendr\'iamos que convertir ambas mol\'eculas (prote\'ina y ligando) al formato \emph{pdbqt} y luego escribir un archivo de configuraci\'on en donde definimos muchos de estos par\'ametros. Al final tendr\'iamos que ejecutar a Vina desde la l\'inea de comando esperando que el proceso nos devuelva otros archivos como resultado. En ellos se hallar\'an los 10 modos hallados: las 10 conformaciones m\'as estables seg\'un las energ\'ias de enlace de el ligando a la mol\'ecula grande. Pero por ahora, vamos a revisar el resultado de haber hecho esto en Chimera.\\

Al terminar el c\'alculo, Chimera abrir\'a una nueva ventana con un listado de resultados. Cada uno es una conformaci\'on, y en el listado hallamos su valor de energ\'ia. Al ir seleccionando cada uno, podemos visualizarlo ya acoplado a la prote\'ina en el sitio activo. Estos resultados son la parte m\'as importante del docking, puesto que en ellos podemos ver qu\'e interacciones hay y por qu\'e. D\'emonos un tiempo para analizar y evaluar el resultado que se nos muestra y el por qu\'e es que sali\'o as\'i. Luego discutamos con los dem\'as.\\

En este punto, lo \'unico que queda es revisar un poco las opciones para visualizar mejor lo que significa esa conformaci\'on del paracetamol en la prote\'ina. Una forma de hacer esto es si vamos a \emph{Select}, \emph{Residue}, \emph{***}. Luego otra vez a \emph{Select}, ahora a \emph{Zone} y con el primer par\'ametro seleccionado, hacemos click en OK. A continuaci\'on, vamos a \emph{Actions}, \emph{Surface}, \emph{show}. Y finalmente a \emph{Actions}, \emph{Surface}, \emph{transparency}, $40\%$. Esto nos dar\'a una mejor idea visual de c\'omo es que se halla el espacio molecular alrededor de nuestro ligando. Si deseamos probar con otras alternativas, no seamos t\'imidos. A la larga, este ejercicio lo podemos repetir en cualquier momento.\\

Felicidades! Terminamos nuestro primer docking. Antes de seguir con la siguiente secci\'on, ser\'ia muy conveniente que discutamos con todos sobre el procedimiento que acabamos de hacer. Qu\'e acabamos de simular? Para qu\'e nos puede servir? Por qu\'e es que este procedimiento no es exacto o no representa bien a la realidad? Qu\'e ventajas/desventajas nos puede dar en un estudio? Y finalmente, en qu\'e tipo de estudio podr\'iamos utilizar esto? Tomemos nuestro tiempo para discutir esto y llegar a una opini\'on.

\subsubsection{Utilizando una L\'inea de Comando}
El docking resulta una tarea muy sencilla cuando se trata de \emph{una sola} mol\'ecula. Pero qu\'e pasa si tenemos que calcular 5000? Considerando que cada mol\'ecula se va a tardar un promedio de 5 minutos, y que no deseamos hacerlo solo en nuestros tiempos libres, pues terminar\'iamos en algunas semanas (si no meses). Automatizar el proceso se ve como una buena opci\'on. Pero c\'omo podr\'iamos hacer eso? Primero necesitamos desprendernos de la interfaz de Chimera.\\

Poniendo todos nuestros conocimientos en pr\'actica, vamos a intentar realizar un docking de nuestra mol\'ecula de ibuprofeno sobre la prote\'ina \textbf{1PXX}. Para ello habr\'ia que realizar dos tareas claves: La primera es preparar nuestras mol\'eculas como \textit{pdbqt}s. La segunda es preparar un archivo de configuraci\'on. Comencemos con algo sencillo antes: preparar el receptor.\\

Lo primero que tenemos que hacer, que no podemos hacer de otra forma, es sacar a DIF de nuestro receptor. Para eso vamos a abrir a \textbf{1PXX} con Chimera, seleccionaremos DIF, abriremos la l\'inea de comando de Chimera y escribiremos \inlinecode{delete selected}. Luego iremos a \emph{File}, \emph{Save PDB ...} y le daremos el nombre de \textbf{1PXXa} en donde dice \emph{File name:}. Ahora ya tenemos nuestro receptor listo sin DIF en el sitio activo. Lo siguiente es convertir esta mol\'ecula y nuestro ligando en formato \emph{pdbqt}.\\

Las mol\'eculas las tenemos en dos formatos distintos: \emph{mol2} y \emph{pdb}. Lo primero que debemos hacer es convertirlas a formato \emph{pdbqt}. Para el ligando, vamos a hacer esto con un programa llamado OpenBabel que llamaremos desde la l\'inea de comando. Vamos a abrir una l\'inea de comando y vamos a ir a donde tenemos nuestras mol\'eculas. Cuando ya estemos all\'i, vamos a escribir: \inlinecode{babel -imol2 ibuprofen.mol2 -opdbqt ibuprofen.pdbqt}. Si nos damos cuenta, lo que estamos haciendo es llamando el programa y d\'andole como entrada la mol\'ecula en un formato, y dici\'endole en qu\'e formato la queremos despu\'es.\\

Para el caso del receptor, vamos a utilizar otro script. OpenBabel podr\'ia hacer la transformaci\'on de \emph{pdb} a \emph{pdbqt}, pero el archivo no resulta teniendo lo necesario para que pueda correr en AutoDock Vina. Por eso usaremos un script que es parte de AutoDockTools. Vamos a ingresar lo siguiente:

\begin{flushleft}
\begin{Code}
$\sim$\hspace*{-2mm} /MGLTools-1.5.6/MGLToolsPckgs/AutoDockTools/Utilities24/prepare\_receptor4.py\ -r\\ \hspace*{4mm}$\sim$\hspace*{-2mm} /ruta a proteina/1PXXa.pdb\ -o $\sim$\hspace*{-2mm} /ruta a proteina/1PXXa.pdbqt\ -A hydrogens
\end{Code}
\end{flushleft}

Si nos damos cuenta, hicimos algo muy similar en este caso. La diferencia es el programa con que hicimos la transformaci\'on. Con esto ya tenemos convertidas las dos mol\'eculas que deseamos. Ahora lo que nos queda hacer es praparar un archivo de entrada. Este archivo no es tan complicado, solo hay que especificarle algunos par\'ametros. Creamos un nuevo archivo de nombre \emph{dock.conf} y le escribimos esto adentro:

\begin{Code}
receptor = 1PXXa.pdbqt\\
ligand = ibuprofen.pdbqt\\
out = dock.pdbqt\\
log = dock.log\\
center\_x = 27\\
center\_y = 25\\
center\_z = 15\\
size\_x = 20\\
size\_y = 20\\
size\_z = 20\\
cpu = 2\\
exhaustiveness = 8\\
num\_modes = 10\\
energy\_range = 3
\end{Code}

Para entender mejor esto, vayamos por pasos. Primero estamos dici\'endole al programa qui\'enes van a ser los involucrados en el docking: el receptor y el ligando. Luego le decimos d\'onde deseamos colocar los resultados del docking (\emph{dock.pdbqt}), y un archivo donde vayamos dejando el r\'ecord de todo lo que ha pasado (\emph{dock.log}). A continuaci\'on definimos el centro de la caja\footnote{Estas coordinadas las sacamos de los datos del docking anterior. A la larga, el sitio activo es el mismo.} dentro de la que haremos el docking en sus coordenadas $x$, $y$ y $z$. Despu\'es definimos el tama\~no de la caja en las 3 dimensiones. Establecemos la cantidad de procesadores que deseamos utilizar, la cantidad de modos que deseamos obtener y el rango de energ\'ias en el que deseamos hallar todos los resultados. Eso es todo! Para correr esto en AutoDock Vina, lo \'unico que debemos hacer en la l\'inea de comando es escribir: \inlinecode{vina --config dock.conf}\\

Para visualizar los resultados, podemos abrir nuestra prote\'ina en UCSF Chimera y luego ir a \emph{Tools}, \emph{Surface/Binding Analysis}, \emph{ViewDock}. All\'i especificamos d\'onde est\'a nuestro archivo de salida (\emph{dock.pdbqt}) y vamos a comenzar a ver los resultados como lo hab\'iamos hecho antes.\\

\subsection{Tareas Repetitivas}

Ahora que ya vimos c\'omo hacer esto con una mol\'ecula, pensemos c\'omo lo podr\'iamos hacer para todas utilizando un script peque\~no en la misma l\'inea de comando. Y mejor a\'un, pensemos c\'omo generar todos los archivos de configuraci\'on con Python. Eso ser\'ia una tarea repetitiva interesante tambi\'en. Pero antes de eso habr\'ia que convertir todas las mol\'eculas ligando a \emph{pdbqt}. Comencemos por all\'i.\\

Todas las mol\'eculas ligando tienen extensi\'on \emph{mol2}, y las queremos en formato \emph{pdbqt}. As\'i que, en esencia, el comando ser\'ia algo como: \inlinecode{babel -imol2 \emph{molecula}.mol2 -opdbqt \emph{molecula}.pdbqt} en donde \emph{molecula} va a ser lo que cambie en cada caso. Ahora, lo que necesitamos es un ciclo que nos vuelva ese proceso autom\'atico. Para ello vamos a escribir lo siguiente:

\begin{Code}
for m in \$(ls *mol2)\\
do\\
obabel -imol2 \$m -opdbqt -O\$\{m\%.*\}.pdbqt\\
done
\end{Code}

La expresi\'on entre llaves y con el signo de porcentaje es solo una manera de pedirle a la l\'inea de comando que quite aquello que tiene un punto y cualquier texto despu\'es, del nombre del archivo que est\'a recibiendo de \inlinecode{m}. Entonces, con este peque\~no pedazo de c\'odigo, hemos transformado todas nuestras mol\'eculas en archivos con formato \emph{pdbqt}. Llevamos el primer paso.\\

Ahora pensemos c\'omo hacer que un script de Python nos produzca todos los archivos de configuraci\'on. En primer lugar necesitamos que Python sepa qu\'e archivos son y nos d\'e los nombres. Para ello podemos utilizar el paquete \inlinecode{os}. Para comenzar podemos saber el directorio donde nos encontramos con la siguiente expresi\'on: \inlinecode{os.getcwd()} Para obtener una lista con los nombres de todos los archivos en un directorio, podemos usar la expresi\'on \inlinecode{os.listdir(\emph{directorio})} Juntando esto, podemos comenzar con lo siguiente:

\begin{Code}
import os\\
archivos = os.listdir(os.getcwd())
\end{Code}

Ahora necesitamos ir archivo por archivo revisando que los que vamos a usar, sean solo los ligandos. Para ello vamos a apovecharnos del hecho de que solo los ligandos ten\'ian formato \emph{mol2} anteriormente. En ese caso, podemos hablar de un ciclo y de una condici\'on. Estos, agregados a lo que ya llev\'abamos se ver\'ian algo as\'i.

\begin{Code}
import os\\
archivos = os.listdir(os.getcwd())\\
for mol in archivos:\\
\hspace*{6mm}if mol[-4:] == "mol2":
\end{Code}

Ahora necesitamos crear un archivo de configuraci\'on. Ser\'ia conveniente utilizar los nombres de las mismas mol\'eculas como los nombres de los archivos de configuraci\'on. En ese caso, vamos a agregar una l\'inea m\'as a lo que llevamos de c\'odigo: \inlinecode{with open(mol[:-4] + ".conf") as arch:} Aqu\'i solo especificamos que abrimos un archivo con el nombre de la mol\'ecla, pero con extensi\'on \emph{conf}. El siguiente paso es escribirle los datos necesarios. El receptor, nuestra prote\'ina \textbf{1PXXa}, es el mismo as\'i como su sitio activo y los par\'ametros de b\'usqueda. Entonces, de lo que vimos en la secci\'on anterior, vamos a copiar casi todo como una cadena grande\footnote{Una cadena grande y continua en Python se delimita con tres commillas dobles al inicio y al final.} y vamos a sustituir solo aquellos valores que nos interesan. El c\'odigo se ver\'ia entonces algo as\'i:

\begin{footnotesize}
\begin{Code}
import os\\
plantilla = "\ \hspace*{-1.5mm}"\ \hspace*{-1.5mm}"\ \hspace*{-1.5mm}receptor = 1PXXa.pdbqt\\
ligand = \{0\}.pdbqt\\
out = \{0\}\_resultados.pdbqt\\
log = \{0\}.log\\
center\_x = 27\\
center\_y = 25\\
center\_z = 15\\
size\_x = 20\\
size\_y = 20\\
size\_z = 20\\
cpu = 2\\
exhaustiveness = 8\\
num\_modes = 10\\
energy\_range = 3"\ \hspace*{-1.5mm}"\ \hspace*{-1.5mm}"\\
archivos = os.listdir(os.getcwd())\\
for mol in archivos:\\
\hspace*{6mm}if mol[-4:] == "mol2":\\
\hspace*{12mm}with open(mol[:-5] + ".conf", "w") as arch:\\
\hspace*{18mm}arch.write(plantilla.format(mol[:-5]))
\end{Code}
\end{footnotesize}

Vale la pena resaltar algunos puntos al llegar aqu\'i. El primero es que los valores a sustituir los colocamos con \inlinecode{\{0\}} para que, con el comando \inlinecode{.format(\emph{sustituto})}, pudieramos cambiar todos a la vez. Tambi\'en vale la pena observar que la manera en que abrimos un archivo para escritura esta vez fue diferente a como lo hab\'iamos visto antes. Aqu\'i no es necesario cerrar el archivo, puesto que esto se hace en autom\'atico al salir de la condici\'on \inlinecode{with}. Este peque\~no script de 20 l\'ineas puede generar todos los archivos de configuraci\'on para AutoDock Vina, sean 5 o 5000, en cuesti\'on de segundos! Ahora ya tenemos todo listo. Solo nos queda correr todos los dockings de forma autom\'atica.\\

El \'ultmo paso para realizar todos los dockings es casi igual al primero. Hay que hacer que un comando en particular se repita muchas veces. El comando es f\'acil: \inlinecode{vina --config \emph{archivo.conf}} en donde \emph{archivo.conf} es el nombre del archivo de configuraci\'on. Entonces lo que nos queda por hacer es listar a todos los archivos de configuraci\'on y hacer un ciclo sobre ellos. Tomando lo mismo que hicimos para transformar las mol\'eculas de un formato a otro, el c\'odigo para esto se ver\'ia as\'i:

\begin{Code}
for c in \$(ls *.conf)\\
do\\
vina --config c\\
done
\end{Code}

Al ejecutar esto, podemos esperar bastante tiempo, puesto que cada docking tomar\'a unos segundos y ahorita se comenzar\'an a hacer en serie. Los resultados si habr\'ia que verlos uno a uno, a menos de que querramos dise\~nar un script que extraiga solo alguna informaci\'on en particular de cada archivo de salida. Eso quedar\'a a criterio de cada uno si alg\'un d\'ia lo llegamos a necesitar. Pero por ahora, podr\'iamos dejar a nuestro ordenador corriendo los dockings y despreocuparnos de \'el hasta que termine.\\

Cuando ya hayamos terminado con el proceso, ser\'ia muy conveniente ver cu\'al de las mol\'eculas que acoplamos a la prote\'ina tuvo la menor energ\'ia. Como dato especial, las mol\'eculas propuestas aqu\'i son analg\'esicos que act\'uan precisamente sobre esta prote\'ina con la que estamos trabajando. Una menor energ\'ia podr\'ia significar un efecto m\'as prolongado de ese analg\'esico y/o un mejor efecto del mismo. Claro, el efecto est\'a sujeto a muchos otros factores cin\'eticos, pero eso ya es tema de discusi\'on para otra ocasi\'on.

\subsection{M\'as all\'a}
Los campos de la quimioinform\'atica y la bioinform\'atica no solo se reducen a estos temas. Estos son mucho m\'as vastos y comprenden otras disciplinas que no se discutieron aqu\'i.

El c\'alculo de descriptores se complica cuando se incluyen resultados de mec\'anica cu\'antica a ellos. A veces quiz\'a an\'alisis de las rotaciones de mol\'eculas y c\'omo esto cambia su ambiente elctrost\'atico. Utilizando esto es que se han hallado nuevas maneras de hacer celdas solares org\'anicas, semiconductores o materiales de alta resistencia.\\

La b\'usqueda de secuencias se torna interesante cuando se hallan variaciones en ellas. Estas mutaciones pueden interpretarse de muchas maneras. De esta forma ya se han hallado segmentos de ADN que codifican enfermedades o alguna caracter\'istica muy especial en alguna especie, y saber interpretar esa informaci\'on es un tema para posgrado. Con el an\'alisis de las secuencias de amino\'acidos o ADN tambi\'en se puede inferir rutas de evoluci\'on y ensamblar \'arboles filogen\'eticos.\\

El docking o acoplamiento molecular puede llevarse a cabo entre un receptor y un ligando, o entre dos prote\'inas, dos mol\'eculas de mediano tama\~no, etc. La t\'ecnica es famosa por utilizarse en qu\'imica medicinal, pero tambi\'en ha sido utilizada en el dise\~no inteligente de agentes para control de plagas, predicci\'on de biodegradabilidad de sustancias, an\'alisis de la funcionalidad de prote\'inas mutadas, etc.\\

Como nos damos cuenta, lo \'unico que hace falta es una buena idea, investigar un poco y comenzar a trabajar. El software ya est\'a escrito en buena medida. Es m\'as! Debemos tomar en cuenta es que el software descrito en este documento es la opci\'on gratuita m\'as accesible. Pero para cada una de las tareas realizadas existen muchos otros paquetes de software que hacen lo mismo o algo similar. Depende de qu\'e es lo que busquemos o qu\'e tan fino necesitemos un c\'alculo es que debemos escoger el software.\\

En este caso particular no es recomendable escribir un nuevo paquete (a menos de que se haga con fines did\'acticos), porque las opciones ya son bastantes y son buenas. Lo que debemos buscar es en d\'onde implementar uno de estos c\'alculos para enriquecer los resultados de alg\'un estudio que estemos haciendo. Podemos verlo, entonces, como una t\'ecnica de laboratorio que nos provee de m\'as informaci\'on.

\subsection{Comentarios Finales}

Felicidades! Has terminado la sesi\'on 8 del $TC^3 Q$. Ahora ya entiendes c\'omo manipular mol\'eculas peque\~nas desde Python, c\'omo calcular descriptores y c\'omo guardar archivos de mol\'eculas. La traves\'ia para entender la manipulaci\'on molecular con nuestro ordenador ya est\'a tomando forma. Tambi\'en aprendiste c\'omo funciona BLAST y qu\'e significan los resultados que te da. Sabes analizar secuencias de amino\'acidos (o ADN), visualizar diferencias y calcular propiedades de ellas. Al final tambi\'en sabes hacer un acomplamiento de dos mol\'eculas calculando la energ\'ia del mismo y teniendo as\'i capacidad predictiva sobre algunas reacciones biol\'ogicas.\\

La quimioinform\'atica y la bioinform\'atica se ocupan da muchas cosas. El c\'alculo y la predicci\'on de propiedades moleculares a partir de su f\'ormula y su estructura es a\'un un tema de estudio. Lo que se busca ahora, sin embargo, es el poder predecir reacciones. Por otra parte, por el lado de la bioinform\'atica, unos de los problemas m\'as complicados a resolver son la alineaci\'on estructural de una prote\'ina con otra, la b\'usqueda y hallazgo de cavidades y sitios activos, la identificaci\'on de sectores espec\'ificos de una prote\'ina (regiones dentro de membranas, regiones fuera de membranas, etc.), creaci\'on y curado de bases de datos de genes, etc. El campo es muy grande y aqu\'i solo vimos un par de aspectos. Tambi\'en es intenresante incursionar en el campo de los modelos matem\'aticos que se utilizan para modelar todo esto y el software que se produce. En resumen, hay mucho en lo que puedes trabajar.\\

De nuevo, felicitaciones por haber terminado esta sesi\'on; es la primera sesi\'on en donde ya estamos viendo algo aplicable. Pr\'oximamente entraremos a estudiar mol\'eculas desde una perspectiva m\'as fina. Estudiaremos formas de hallar sus conformaciones m\'as estables, sus orbitales, un poco de termodin\'amica y al final veremos c\'omo es que se comporta ya una colecci\'on de mol\'eculas al simularlas en un ambiente. Hasta entonces, repasa lo que viste hoy, intenta cambiar par\'ametros y entender c\'omo funciona todo y b\'uscale aplicaciones. Esto solo puede ser tan bueno como tu quieras que sea.

\section*{Licencia}

\noindent \includegraphics{img/cc_big.png}

\noindent Taller de Qu\'imica Computacional Aplicada by \href{http://github.com/zronyj/TC3Q}{Rony J. Letona} is licensed under a \href{http://creativecommons.org/licenses/by-sa/4.0/}{Creative Commons Attribution-ShareAlike 4.0 International License}.
Based on a work at \url{http://pythonforbiologists.com/}.

\end{document}