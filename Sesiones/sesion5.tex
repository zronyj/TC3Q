%
% sesion5.tex
% 
% Copyright 2017 Rony J. Letona <zronyj@gmail.com>
% 
% This program is free software; you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation; either version 2 of the License, or
% any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
% MA 02110-1301, USA.
%

\documentclass[10pt,letterpaper]{article}
\usepackage[latin1]{inputenc}
\usepackage[spanish]{babel}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{color}
\usepackage{float}
\usepackage{upquote}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\author{Rony J. Letona}
\title{Taller de Computaci\'on Cient\'ifica para Ciencias Qu\'imicas: Sesi\'on 5}
\definecolor{light-gray}{gray}{0.90}

\newcommand{\tab}[1]{\hspace{.2\textwidth}\rlap{#1}}

\newcommand{\inlinecode}[1]{
\colorbox{light-gray}{\texttt{#1}}
}

\newsavebox{\selvestebox}
\newenvironment{Code}
{
\begin{lrbox}{\selvestebox}%
\begin{minipage}{\dimexpr\columnwidth-2\fboxsep\relax}
\fontfamily{\ttdefault}\selectfont
}
{\end{minipage}\end{lrbox}%
\begin{center}
\colorbox{light-gray}{\usebox{\selvestebox}}
\end{center}
}

\newcommand{\Picture}[1]
{
	\begin{figure}[H]
	\begin{flushleft}
	\includegraphics[width=\columnwidth]{#1}
	\end{flushleft}
	\end{figure}
}

\begin{document}
\maketitle

\section{Principios de Programaci\'on para las Ciencias 2}
Los ordenadores, o computadoras, fueron inventados en una \'epoca en la que ya se sab\'ia hacer muchas operaciones matem\'aticas, pero estas requer\'ian de mucho esfuerzo. Estas, entonces, se inventaron con el fin de hacer estas operaciones matem\'aticas m\'as r\'apida- y eficientemente. Primero fueron aparatos mec\'anicos con engranajes y palancas. Luego se pas\'o a la electr\'onica que, haciendo uso de tubos de vac\'io, llev\'o al nacimiento de los primeros procesadores. Con el descubrimiento de los semiconductores se pas\'o a los transistores; estos permitieron la construcci\'on de microprocesadores que llevaron a que todo se tornara m\'as peque\~no. Lo importante, sin embargo, siempre ha sido la realizaci\'on de c\'alculos complicados en poco tiempo.\\

La desventaja de los c\'alculos de los que estamos hablando es que no se pueden resolver como una ecuaci\'on. Generalmente se trata de problemas en los que debemos ir probando valores distintos hasta hallar el que hace verdadera una ecuaci\'on. Tomemos como ejemplo el estimar el valor de $\pi$. Esta tarea se propuso hace miles de a\~nos y la idea era ir dividiendo la circunferencia de varios pol\'igonos regulares entre la distancia entre los dos puntos m\'as distantes del mismo. Entre m''as lados tuviera el pol\'igono, mejor ser\'ia la aproximaci\'on. El problema, claro era ir recalculando para pol\'igonos m\'as grandes. Este tipo de problemas llev\'o a hacer c\'alculos que se tienen que repetir varias veces hasta cumplir con una condici\'on.\\

Hasta ahora hemos escrito y construido rutinas que, b\'asicamente, realizan lo propuesto en una f\'ormula una vez les damos los argumentos necesarios. Ahora vamos a aprovechar la capacidad de nuestro ordenador de tomar decisiones y de realizar tareas de manera iterativa. Esto nos dar\'a la oportunidad de realizar mucho mejores rutinas y hasta programas. Comencemos a hacer \textbf{buen} uso de nuestro ordenador.

\pagebreak

\subsection{Condiciones y Tareas Repetitivas}
Una de las cosas m\'as \'utiles al estar creando un script o programa es la capacidad de nuestro ordenador de elegir un camino a seguir. Si nos damos cuenta atentamente, en el script que calculaba temperaturas, dise\~namos algo que nos permit\'ia elegir: depende del n\'umero ingresado, entonces se nos muestra algo. Pero esa forma de hacerlo se siente un tanto complicada. De hecho, en nuestro script hicimos todos los c\'alculos y, la verdad, no era necesario hacerlos todos. Solo el que necesit\'abamos. Por eso, ahora veremos una forma en la que nuestro ordenador puede elegir un camino a seguir dependiendo de alguna circunstancia.\\

Por otra parte, otra cosa que puede hacer nuestro ordenador, y que nos ayudar\'a mucho en un futuro, es el hecho de poder repetir un proceso varias veces sin que nosotros tengamos que pedirle que lo vuelva a hacer cada vez. Esto es muy \'util en el caso en el que trabajemos con listas o con diccionarios. Tambi\'en lo ser\'a cuando calculemos algunas cosas como promedios o sumas de muchos datos. Esto lo veremos un poco despu\'es de las decisiones, porque este tipo de comando \emph{c\'iclico} se basa muchas veces en condiciones.

\subsubsection{Decisiones}
Comencemos con algo sencillo. Una decisi\'on es una especie de bifurcaci\'on o encrucijada que nos propone dos o m\'as caminos a seguir. Para mantener las cosas sencillas, vamos a pensar en un camino que se divide en dos. Si se trata de un caso as\'i, nuestra pregunta, naturalmente, ser\'ia algo del tipo: ``Y ahora, para d\'onde?'' Inmediatamente comenzamos a buscar alguna condici\'on que se cumpla para escoger un camino: ``Si X cosa se cumple, me voy por el primer camino. Si no, me voy por el otro.'' Esa condici\'on puede ser: que el camino sea menos dif\'icil, que el camino me lleve a donde quiero, etc. La cosa es que hay una condici\'on que puede ser \emph{verdadera} o \emph{falsa} que determina nuestra decisi\'on.\\

Vamos a traducir esto al lenguaje de nuestro ordenador. Tenemos entonces que si una condici\'on (una comparaci\'on de valores) resulta en \emph{verdadero} o \emph{falso} (un booleano), entonces algo va a pasar. Veamos un ejemplo en particular. Si la variable \inlinecode{var} es mayor a 10, entonces vamos a ejecutar \inlinecode{print "var es MAYOR a 10"}. Si no, vamos a ejecutir \inlinecode{print "var es menor a o igual a 10"} Entonces, nuestro c\'odigo se va a ver algo as\'i.

\begin{Code}
if var >\ 10:\\
\hspace*{5mm} print "var es MAYOR a 10"\\
else:\\
\hspace*{5mm} print "var es menor o igual a 10"
\end{Code}

Claro, antes de ejecutar esto hay que darle un valor a \inlinecode{var}, pero en general, vemos que esto funciona. Debemos notar, sin embargo, que dejamos 4 espacios antes de cada comando despu\'es de la condici\'on. A esto se le llama indentaci\'on. La regla es: \textit{Todo aquello que dependa de la condici\'on para ser ejecutado, va indentado.} La verdad, es una forma de ordenar nuestro c\'odigo para que el ordenador sepa qu\'e debe de correr, cu\'ando y en qu\'e condiciones. Veamos nuestro script de las temperaturas nuevamente para ver eso y, adem\'as, una implementaci\'on de cuando pueden haber varios caminos a seguir.

\begin{small}
\begin{Code}
print "********** Convertidor **********"\\
print "1. F -> C \textbackslash t 2. C -> F"\\
print "3. C -> K \textbackslash t 4. K -> C"\\
print "5. F -> K \textbackslash t 6. K -> F"\\
b = 32\\
f = 5.0/9\\
a = 273.15\\
opcion = input("\ \hspace{-2mm}Ingrese el numero de operacion que desea realizar: ")\\
temperatura = raw\_input("\ \hspace{-2mm}Ingrese la temperatura a ser calculada: ")\\
temperatura = float(temperatura)\\
print "Temperatura en grados",\\
if opcion == 1:\\
\hspace*{5mm} print "\ \hspace*{-2mm}C:", (temperatura - b) * f\\
elif opcion == 2:\\
\hspace*{5mm} print "F:", temperatura * 1/f\ +\ b\\
elif opcion == 3:\\
\hspace*{5mm} print "K:", temperatura\ +\ a\\
elif opcion == 4:\\
\hspace*{5mm} print "\ \hspace*{-2mm}C:", temperatura - a\\
elif opcion == 5:\\
\hspace*{5mm} print "K:", (temperatura - b) * f\ +\ a\\
elif opcion == 6:\\
\hspace*{5mm} print "F:", (temperatura - a) * 1/f\ +\ b
\end{Code}
\end{small}

Esto, aunque se vea m\'as largo, es m\'as eficiente y mucho m\'as autoexplicativo. Comentemos con nuestro compa\~nero de al lado qu\'e creemos que hace el comando \inlinecode{if}, el comando \inlinecode{elif} y el comando \inlinecode{else} Posteriormente comentemos sobre por qu\'e es que este c\'odigo resulta m\'as eficiente que el anterior que ten\'iamos y m\'as f\'acil de entender. Finalmente tomemos nota de lo que acabamos de aprender y tomemos un momento para pensar en qu\'e casos es esto importante\footnote{Notemos que ahora utilizamos n\'umeros del 1 al 6.}.

\subsubsection{Repetir mientras llega la Condici\'on}
Bueno, ahora que ya entendimos las condiciones un poco, podemos comenzar a jugar con otras cosas m\'as interesantes. Hasta ahora hemos utilizado algo de la forma: ``Si X condici\'on se cumple, entonces Y cosa sucede.'' Pero, qu\'e pasar\'a cuando en vez de \emph{si}, utilizamos \emph{mientras}? La frase se ver\'ia algo as\'i: ``Mientras X condici\'on se cumpla, entonces Y cosa sucede.'' A pesar de que el cambio se ve sencillo, el significado acaba de cambiar radicalmente. En el caso anterior, evalu\'abamos la condici\'on una vez. Ahora, evaluamos la condici\'on repetidas veces hasta que esta se deje de cumplir.\\

Veamos esto ya en c\'odigo. La idea ahora es hallar una palabra que represente ese ``mientras''. Para eso, nuestro ordenador nos ofrece \inlinecode{while}. Ahora, antes de intentar cualquier cosa, recordemos que un script o una rutina se detiene presionando las teclas \inlinecode{Ctrl} y \inlinecode{C} al mismo tiempo. Ahora procedamos a probar qu\'e hace un \inlinecode{while}.

\begin{Code}
while var <\ 10:\\
\hspace*{5mm} print "Vuelta!"
\end{Code}

De nuevo recordemos que si no le asignamos un valor a \inlinecode{var}, entonces obtendremos un error. Al correr esto, es posible que tengamos que detener el script, porque ... no hay mecanismo en que \'el pare solo; seguir\'a repitiendo lo mismo por siempre.\\

Cuando ya estemos listos para continuar, vamos a ver un ejemplo un poco m\'as aplicado. Vamos a tomar una mol\'ecula en SMILES y vamos a ver si hallamos un hal\'ogeno en ella. Para eso necesitamos ir de letra en letra a lo largo de la cadena con la mol\'ecula y detenernos justo cuando hallemos \textbf{F}, \textbf{Cl}, \textbf{Br} o \textbf{I}. Pensemos entonces: necesitamos que el usuario ingrese la cadena, que algo vaya avanzando letra por letra de manera \emph{c\'iclica} y en el camino identificar si esa letra pertenece a un hal\'ogeno. Lo primero que vamos a necesitar entonces es una variable \inlinecode{contador} que vaya contando cada vuelta que da el \inlinecode{while} y nos vaya ayudando a accesar cada letra en la cadena. Luego, necesitaremos una serie de condiciones para revisar si la letra que estamos accesando en la cadena pertenece a un hal\'ogeno. Notemos puede tratarse de dos letras! Veamos pues el c\'odigo de nuestro script.

\begin{Code}
molecula = raw\_input("Por favor ingrese molecula en formato SMILES: ")\\
contador = 0\\
while contador <\ len(molecula):\\
\hspace*{5mm} letra = molecula[contador]\\
\hspace*{5mm} if letra == "F":\\
\hspace*{13mm} print "Hay un halogeno!"\\
\hspace*{13mm} break\\
\hspace*{5mm} elif letra == "\ \hspace*{-2mm}C":\\
\hspace*{13mm} if molecula[contador\ +\ 1] == "l":\\
\hspace*{21mm} print "Hay un halogeno!"\\
\hspace*{21mm} break\\
\hspace*{5mm} elif letra == "B":\\
\hspace*{13mm} if molecula[contador\ +\ 1] == "\ \hspace*{-2mm}r":\\
\hspace*{21mm} print "Hay un halogeno!"\\
\hspace*{21mm} break\\
\hspace*{5mm} elif letra == "\ \hspace*{-2mm}I":\\
\hspace*{13mm} print "Hay un halogeno!"\\
\hspace*{13mm} break\\
\hspace*{5mm} contador = contador + 1
\end{Code}

Primero, intentemos correr esto para ver que realmente hace lo que se supone que debe de hacer. Aqu\'i tenemos una mol\'ecula en SMILES para probar: CC(C)CC(C\#N)C(C(C)C)C(=O)CSC(F)C(N)=O. Una vez hayamos probado nuestro script, vamos a proceder a estudiarlo. Hay una palabra nueva que no hab\'iamos visto antes: \inlinecode{break} Esta nos sirve para detener el ciclo \inlinecode{while} en el caso que sea necesario. Luego, con nuestro compa\~nero de al lado discutamos qu\'e creemos que hace cada parte. Hay dos cosas a las que debemos ponerle mucha atenci\'on: la indentaci\'on y la variable \emph{contador}. Qu\'e le pasa a la variable \inlinecode{contador} en cada ciclo? Para qu\'e nos sirve y c\'omo es que lo hace? Qu\'e hace la variable \inlinecode{letra}? Por qu\'e tenemos un \inlinecode{if} metido dentro de un \inlinecode{elif}\footnote{Para qu\'e nos sirve revisar otra vez la mol\'ecula? Que acaso es importante la siguiente letra despu\'es de la que estamos revisando en un momento dado?}? Tomemos nota de todo lo que aprendamos e intentamos pensar en c\'omo podr\'iamos optimizar m\'as este c\'odigo tambi\'en\footnote{Hay algo que se repita de igual manera muchas veces?}. Preguntemos por \inlinecode{if} con m\'as de una condici\'on.

\subsubsection{Repetir sobre Elementos de una Lista}
Por el momento, debemos admitir que es un poco tedioso tener una condici\'on, un contador y asegurarse de parar el ciclo cada vez que una condici\'on se cumple. Bueno, lo de las condiciones es un poco inevitable, pero las otras dos cosas podemos cambiarlas. Existe otra herramienta, en vez de \inlinecode{while}, que no solo repite, sino que puede ir iterando sobre los elementos de una lista. C\'omo as\'i? Pues no es tan complicado. Si tenemos, por ejemplo, una lista de la siguiente forma: \inlinecode{[1, 2, 3, 4, 5]} esta nueva herramienta va a permitirnos que se realicen instrucciones con los 5 elementos de la lista. Es como tener un \inlinecode{while} con un contador, pero sin la necesidad de ir sum\'andole al contador o ir revisando una condici\'on. En vez de eso, nuestra herramienta va utilizando los elementos de la lista que le demos. Veamos un ejemplo:

\begin{Code}
for i in [8, 7, 9, -1, 3.1415, "\ \hspace*{-2mm}abc"]:\\
\hspace*{5mm}print i
\end{Code}

Corramos estas dos peque\~nas l\'ineas y analicemos qu\'e es lo que acaba de pasar. Posteriormente discutamos con nuestro compa\~nero de al lado.\\

Algo importante que vale la pena mencionar es que una lista la podemos generar de la siguiente manera: \inlinecode{range(n)} donde \textbf{n} es la cantidad de elementos que deseamos en la lista: una lista del 0 a \textbf{n}. Tambi\'en podemos hacer cosas como \inlinecode{range(5,20)} lo cual nos genera una lista de n\'umeros enteros del 5 al 19. O tambi\'en podemos hacer algo como \inlinecode{range(20,4,-5)} generando as\'i una lista de la siguiente forma: \inlinecode{[20, 15, 10, 5]}. Intentemos hacer algo interesante con esta nueva forma de hacer procesos c\'iclicos.\\

Supongamos que tenemos una lista de datos como esta:
\begin{Code}
datos = [6.66, 9.751, 10.112, 10.03, 9.01, 13.948, 13.33, 6.096, 7.585, 11.914, 13.037, 4.872, 7.315, 9.24, 11.266, 9.276, 11.228, 11.629, 9.298, 15.026, 3.772, 11.131, 7.46, 8.193, 15.686, 8.428, 1.019, 10.978, 7.13, 11.602, 7.683, 13.229, 14.394, 7.0, 10.243, 11.1, 8.642, 11.586, 9.933, 7.703, 9.753, 13.589, 2.959, 9.956, 13.172, 7.277, 9.216, 15.341, 15.295, 8.211]
\end{Code}
Ahora vamos a calcular la media y la desviaci\'on est\'andar de estos 50 datos. Generalmente esto es un proceso muy largo de hacer en una calculadora, pero en este caso intentaremos simplificarlo. Para estar claros, en este proceso necesitaremos el tama\~no de la lista, la suma todas las entradas en la lista, la media y la suma de la diferencia de los cuadrados. Para tener una mejor idea, solo repasemos brevemente la f\'ormula para media y desviaci\'on est\'andar de un conjunto de datos $X$.

\begin{equation}
\bar{x} = \frac{\sum_{i = 1}^{N} \left( x_i \right)}{N}
\end{equation}

\begin{equation}
\sigma_x = \sqrt{\frac{\sum_{i = 1}^{N} \left( x_i - \bar{x} \right)^2}{N - 1}}
\end{equation}

Ahora que ya recordamos c\'omo calcular la media y la descviaci\'on, vamos a proceder a calcular las cosas que anotamos antes. Primero, la suma de todos los n\'umeros en la lista:

\begin{Code}
suma = 0\\
for i in datos:\\
\hspace*{4mm} suma += i
\end{Code}

Como siempre, estudiemos el c\'odigo, y posteriormente discut\'amoslo. Hay una cosa en particular que puede llamarnos la atenci\'on: \inlinecode{suma += i} Esta operaci\'on es equivalente a escribir \inlinecode{suma = suma + i} Pero lo escribimos de una manera m\'as compacta para no redundar tanto. Ahora procedamos a determinar la cantidad de los datos y la media:

\begin{Code}
n = len(datos)\\
media = suma / n
\end{Code}

Perfecto! Ya tenemos la media de los datos en 5 l\'ineas simples de c\'odigo. Ahora vamos a calcular la suma de las diferencias al cuadrado, y finalmente la desviaci\'on est\'andar.

\begin{Code}
cuadrados = 0\\
for j in datos:\\
\hspace*{4mm} cuadrados += (j - media)**2\\
desviacion = (cuadrados / (n - 1))**0.5
\end{Code}

Genial! Con 4 l\'ineas m\'as, ya hemos calculado la desviaci\'on est\'andar. Analizemos qu\'e es lo que significa este c\'odigo, compar\'emoslo con las f\'ormulas y concluyamos.\\

Ahora, antes de pasar a la siguiente secci\'on, hay dos cosas que debemos tomar en cuenta. La primera es que la \emph{funci\'on} \inlinecode{range(n)} puede generarnos una lista de n\'umeros enteros, pero la \emph{funci\'on} \inlinecode{xrange(n)} solo la genera dentro de ciclos \inlinecode{for} sin almacenarla en la memoria de nuestro ordenador. Esto significa que si usamos \inlinecode{xrange(n)} dentro de los ciclos \inlinecode{for}, nuestras rutinas ser\'an m\'as r\'apidas.\\

La segunda cosa a la que debemos de notar es que al calcular la suma de todos los n\'umeros de una lista, como lo hicimos en el ejercicio anterior, escribir un ciclo \inlinecode{for} puede ser todav\'ia tedioso para algunos. Por eso, Python cuenta con una \emph{funci\'on} que nos simplifica ese proceso: \inlinecode{sum(lista)}. Para entender mejor esta \emph{funci\'on}, recordemos el mismo ejercicio que realizamos la sesi\'on anterior y consideremos esto: \inlinecode{suma = sum(datos)} Esta \'ultima operaci\'on nos evita las primeras 3 l\'ineas de este ejercicio. Ser\'a que hacemos el intento de simplificarlo de esta manera?

\subsection{Paquetes y Funciones}
Hemos llegado a un punto en el que podemos hacer bastantes cosas ya. Si consideramos que en estad\'istica, las operaciones no pasan de sumas, restas, multiplicaciones, divisiones y operaciones con potencias, nos damos cuenta de que ya podemos hacer an\'alisis estad\'isticos bastante decentes. Sin embargo, hay otras serie de operaciones que nos hacen falta para poder hacer matem\'atica de la manera en que conocemos. Nos faltan funciones como \emph{seno}, \emph{coseno}, \emph{tangente}, \emph{logaritmos}, \emph{exponenciales}, etc. Para eso vamos a aprender que existen colecciones de funciones guardadas en \textbf{paquetes}, los cuales podemos simplemente importar y utilizar.\\

Pero qu\'e pasa cuando queremos hacer algo muy espec\'ifico que no est\'a en ning\'un paquete? Una funci\'on personalizada o muy espec\'ifica? O qu\'e pasa cuando cierto segmento de instrucciones lo tenemos que usar varias veces en diferentes parte de nuestro c\'odigo? Para ello es muy conveniente el poder crear nosotros nuestras propias funciones, y m\'as a\'un, nuestros propios paquetes. Esto tambi\'en lo vamos a ver r\'apidamente, y veremos que es mucho m\'as f\'acil de lo que hemos visto hasta ahora.

\subsubsection{Paquetes}
Trabajar con paquetes resulta, en la mayor parte de lenguajes de programaci\'on, una tarea bastante sencilla. En Python, sin embargo, hay que tomar en cuenta que llamarlos (para poder usarlos) se puede hacer de dos formas y el resultado de esto es un poco diferente. Estas dos formas son:

\begin{enumerate}
\item Llamar a las funciones de un paquete para que estas se integren a nuestra rutina y no nos volvamos a recordar del paquete. Esto tambi\'en nos permite llamar exclusivamente a algunas funciones de un paquete.
\item Llamar el paquete de una forma en la que siempre nos tenemos que referir primero al paquete y despu\'es a las funciones dentro de \'el. Esta forma hace que importemos \emph{todo} lo que hay dentro del paquete.
\end{enumerate}

Veamos el primer caso. En una l\'inea de comando Python vamos a ingresar el siguiente comando:\\
\inlinecode{from math import log e} De esta forma estamos importando el logaritmo natural y la constante exponencial \textbf{e} a esta sesi\'on. Ahora, podemos escribir algo como \inlinecode{log(e)} que nos deber\'ia dar \inlinecode{1.0} como resultado. Analicemos ahora lo que hicimos. La palabra \inlinecode{from} se\~nala el paquete del cu\'al vamos a sacar nuestras funciones o constantes. El paquete que se\~nalamos en este caso es el paquete \textbf{math}. La palabra \inlinecode{import} es la que hace toda la acci\'on de llamar a las funciones que deseamos del paquete. Finalmente, le solicitamos a Python que solo llame a la funci\'on \textbf{log} y a la constante \textbf{e}.\\

Eso fue bastante sencillo. Las funciones quedan libres, como la funci\'on \inlinecode{sum()} que hab\'iamos visto en la secci\'on anterior. Todo est\'a bien. Un dato curioso a considerar es que si deseamos importar todas las funciones y constantes de un paquete, no es necesario saberlas de memoria. En vez de listarlas despu\'es de \inlinecode{import} solo colocamos un asterisco para referirnos a todo lo que hay en el paquete. El resultado en el caso del paquete \textbf{math} se ver\'ia as\'i: \inlinecode{from math import *}.\\

Ahora analicemos el segundo caso. Este resulta, para muchos, como una forma m\'as ordenada de hacer las cosas, puesto que debemos recordar al paquete de donde sali\'o cada funci\'on. Repitiendo lo mismo que hicimos en el ejercicio anterior, vamos a importar el paquete \textbf{math}, pero de la \emph{otra} manera: \inlinecode{import math}. En este caso la palabra \inlinecode{import} va a importar todo el contenido de un paquete. Entonces, con lo que acabamos de hacer, importamos el paquete math completo; no podemos solicitar solo algunas funciones si lo hacemos as\'i. Ahora para utilizar las funciones como en el ejemplo anterior escribimos: \inlinecode{math.log(math.e)}. Como nos damos cuenta, tenemos que referirnos al paquete \emph{cada vez} que vamos a utilizar una funci\'on del mismo.\\

Esta forma de importar paquete es un poco m\'as ordenada, puesto que tenemos que saber de qu\'e paquete viene cada una. Un dato curioso de esta forma es que si no queremos utilizar el nombre original del paquete, lo podemos cambiar. Para hacer esto, vamos a escribir \inlinecode{import math as matematica}. Ahora, si deseamos utilizar funciones del paquete \textbf{math}, podemos referirnos a ellas como \inlinecode{matematica.log(matematica.e)}.

\subsubsection{Usando Funciones}
Antes de proceder a jugar con funciones de otros paquetes, recordemos las funciones que ya tiene Python. Hemos visto que existe \inlinecode{sum()} para sumar todos los elementos de una lista. Pero tambi\'en existen \inlinecode{min()} y \inlinecode{max()} para extraer el elemento m\'as peque\~no y m\'as grande de una lista respectivamente. Ahora, sin embargo, hemos expandido nuestra capacidad de hacer operaciones con funciones espec\'ificas para matem\'atica.\\

Las funciones del paquete \textbf{math}, a pesar de ser pocas, resultan muy \'utiles. Para averiguar todas las funciones que trae el paquete, podemos ingresar \inlinecode{dir(math)} si es que importamos el paquete con \inlinecode{import math}. Como podemos ver, tenemos muchas funciones que pueden sernos muy \'utiles: seno, coseno, tangente, logaritmo natural, logaritmo base 10, el factorial, la funci\'on gamma, etc. Hay muchas cosas que podemos utilizar para hacer c\'alculos m\'as complejos. C\'alculos como cu\'ales? Intentaremos un ejemplo de an\'alisis inorg\'anico.\\

Intentaremos calcular algo m\'as interesante utilizando una de estas funciones: el logaritmo base 10. Existe una ecuaci\'on en qu\'imica anal\'itica que nos sirve para calcular el pH de un buffer cuando contamos con la concentraci\'on del \'acido y de su forma como sal. Comencemos asumiendo que tenemos un buffer de acetatos. La constante $K_a $ es de $ 1.8 \cdot 10^{-5}$ y resulta que deseamos saber el pH al cual est\'a una soluci\'on. Siguiendo la ecuaci\'on de Henderson-Hasselbalch, podemos calcular esto f\'acilmente.

\begin{equation}
pH = pK_a + \log \left( \frac{\left[A^-\right]}{\left[HA\right]} \right)
\end{equation}

Entonces, si tenemos que $\left[HA\right] = 0.1 M$ y que $\left[A^-\right] = 0.025 M$, calcular esto en Python se ver\'ia de la siguiente forma:

\begin{Code}
from math import log10\\
K = 1.8E-5\\
A = 0.025\\
HA = 0.1\\
print "pH =", -1 * log10(K) + log10(A/HA)
\end{Code}

Como vemos, las funciones las podemos utilizar dentro de operaciones matem\'aticas y tantas veces como deseamos. Resulta entonces muy sencillo dise\~nar scripts que calculen datos mediante operaciones matem\'aticas m\'as complejas. Sin embargo, hay veces que estas funciones no son suficientes. Los paquetes nos proveen de una gran cantidad de funciones, pero no todas las que necesitamos. Para eso vamos a crear nosotros nuestras propias funciones.

\subsubsection{Nuestras Funciones}
Cuando deseamos \emph{crear} una nueva funci\'on en la clase de matem\'atica, generalmente decimos que vamos a \emph{definirla}. Por esta misma raz\'on, a la hora de de crear una funci\'on en Python, vamos a utilizar la palabra \inlinecode{def} Adem\'as de esto le tenemos que poner alg\'un nombre a nuestra funci\'on. En este caso, el nombre es totalmente libre de poner, al igual que el nombre de las variables. Finalmente, debemos especificar qu\'e datos le vamos a dar a nuestra variable para que funcione. Adem\'as, al final de la funci\'on podemos hacer que esta nos devuelva (o no) otro dato o datos con la palabra \inlinecode{return}. Ve\'amoslo real: vamos a crear una funci\'on \textbf{media} que nos calcular\'a la media de todos los datos en una lista.

\begin{Code}
def media(una\_lista):\\
\hspace*{4mm} suma = float(sum(una\_lista))\\
\hspace*{4mm} largo = len(una\_lista)\\
\hspace*{4mm} return suma / largo
\end{Code}

Si ingresamos esto en Python, nos daremos cuenta de que no pasa nada. Esto se debe a que solo creamos una funci\'on. Por ahora ella existe igual que una variable; no har\'a nada a menos de que la llamemos y la hagamos funcionar. Un par de detalles a notar es que ingresamos una lista inexistente llamda \inlinecode{una\_lista}. Esta lista no es una variable exactamente. Esta solo est\'a se\~nalando el lugar donde ir\'a el dato que le vamos a ingresar a la funci\'on. En otras palabras, cuando llamemos \inlinecode{media([2.54,2.57,2.53,2.54,2.56,2.56])} entonces \inlinecode{una\_lista} ser\'a igual a \inlinecode{[2.54,2.57,2.53,2.54,2.56,2.56]} y todas las operaciones aplicadas a \inlinecode{una\_lista} se le aplicar\'an a la lista de datos. El otro detalle a considerar es que dentro de la funci\'on definimos algunas variables. Estas solo existen dentro de la funci\'on, no afuera. Si intentamos llamar a \inlinecode{suma} fuera de la funci\'on, Python nos advertir\'a que la variable no existe.\\

Ahora que ya hemos hecho nuestra primera funci\'on, intentemos hacer lo mismo con la desviaci\'on est\'andar. Debemos de recordar que para eso necesitamos calcular la media, as\'i que el siguiente segmento de c\'odigo debe de ir justo despu\'es del anterior en el mismo documento.

\begin{Code}
def desviacion\_est(una\_lista):\\
\hspace*{4mm} med = media(una\_lista)\\
\hspace*{4mm} cuadrados = [(i - med)**2 for i in una\_lista]\\
\hspace*{4mm} varianza = sum(cuadrados) / ( len(una\_lista) - 1 )\\
\hspace*{4mm} return varianza**0.5
\end{Code}

Ahora ya podemos calcular la desviaci\'on est\'andar con una sola funci\'on. Esto es bastante conveniente, porque ya no tenemos que escribir tanto y adem\'as, nuestro c\'odigo se va volviendo m\'as f\'acil de entender. Algo importante a notar es que utilizamos nuestra funci\'on para calcular medias \emph{dentro} de esta nueva funci\'on\footnote{Utilizar funciones dentro de funciones s\'i se puede hacer. Utilizar variables de afuera, dentro de una funci\'on no se puede hacer a menos de que se coloquen dentro de los par\'entesis de la funci\'on; como \textit{argumentos}.}. Hay una cosa extra\~na que utilizamos en esta \'ultima funci\'on que vale la pena que revisemos. Utilizamos un \inlinecode{for} dentro de corchetes, sin utilizar dos puntos, y poniendo la operaci\'on que normalmente va debajo del \inlinecode{for} antes de \'el. Esta es otra forma de crear listas de manera m\'as r\'apida y en una sola l\'inea. Comenta con tu compa\~nero de al lado sobre las funciones que hemos ido creando y c\'omo podr\'iamos hacerlas m\'as eficientes y mejores. Por ahora, vamos a crear dos funciones m\'as para que veamos dos \'ultimos puntos importantes.\\

Es posible crear funciones que no devulevan ning\'un dato o valor, sino que muestren o solo guarden algo. Esto no es nada extra\~no. Generalmente podemos crear funciones que nos muestren algo de manera gr\'afica\footnote{O m\'as o menos gr\'afica haciendo uso de s\'imbolos ASCII.} o que guarden datos en un documento. Todo esto sin devolver nada. Intentaremos hacer ahora una funci\'on que no devuelva nada, sino que nos muestre los datos de una lista de listas (una matriz o tabla). Para ello se nos presenta aqu\'i la funci\'on y la idea es que la veamos, la estudiemos, la ejecutemos y analicemos lo que hace.

\begin{small}
\begin{Code}
def tabla(datos, tiene\_titulos):\\
\hspace*{4mm} titulos = "|"\\
\hspace*{4mm} if tiene\_titulos:\\
\hspace*{11mm} segunda\_linea = "|"\\
\hspace*{11mm} tiene\_segunda\_linea = False\\
\hspace*{11mm} for nombre in datos[0]:\\
\hspace*{18mm} largo = len(nombre)\\
\hspace*{18mm} if largo >\ 18:\\
\hspace*{25mm} tiene\_segunda\_linea = True\\
\hspace*{25mm} titulos += "\ "\ + nombre[:18] + "\ |"\\
\hspace*{25mm} segunda\_linea += "\ "\ * (37 - largo) + nombre[18:] + "\ |"\\
\hspace*{18mm} else:\\
\hspace*{25mm} titulos += "\ "\ *\ (19 - largo) + nombre + "\ |"\\
\hspace*{25mm} segunda\_linea += "\ "\ * 19 + "\ |"\\
\hspace*{11mm} print titulos\\
\hspace*{11mm} if tiene\_segunda\_linea:\\
\hspace*{18mm} print segunda\_linea\\
\hspace*{11mm} print "\ \hspace*{-2mm}-"\ *\ len(segunda\_linea)\\
\hspace*{11mm} datos = datos[1:]\\
\hspace*{4mm} else:\\
\hspace*{11mm} print "\ \hspace*{-2mm}-"\ *\ (21 * len(datos[0]) + 1)\\
\hspace*{4mm} for linea in datos:\\
\hspace*{11mm} fila = "|"\\
\hspace*{11mm} for dato in linea:\\
\hspace*{18mm} dato = str(dato)\\
\hspace*{18mm} fila += "\ "\ *\ (19 - len(dato)) + dato + "\ |"\\
\hspace*{11mm} print fila
\end{Code}
\end{small}

Como recomendaci\'on para probar esta funci\'on, ser\'ia interesante tomar la siguiente idea:

\begin{Code}
muestreo = [["\ \hspace*{-2mm}id", "\ \hspace*{-2mm}Energias", "No. de atomos"],[1, -42.93, 16],[2, -37.24, 14],[3, -39.27, 16],[4, -40.12, 15]]\\
tabla(muestreo, True)
\end{Code}

Con esto podemos ver mejor y m\'as claramente lo que estamos tratando de hacer. Despu\'es de analizarla y entenderla, busquemos discutirla con nuestro compa\~nero de al lado e intercambiar opiniones. Quiz\'a no nos d\'e tiempo de discutir cada detalle y aspecto, pero intentemos hablar de la idea general de la funci\'on y las estructuras que vemos en ella. Notemos tambi\'en la falta de un \inlinecode{return} y c\'omo esto la vuelve diferente a las que hemos visto antes.\\

Entonces, hay dos cosas que debemos de tomar en cuenta. Primero, que hay funciones que nos ayudan a visualizar cosas. Estas quiz\'a no produzcan una salida que podamos usar dentro de nuestro ordenador, pero s\'i algo que nos servir\'a a nosotros para interpretar lo que est\'a pasando. Y segundo, que son generalmente las partes gr\'aficas de un programa las que m\'as tiempo nos quitar\'an al programarlas; estas ser\'an bastante largas.\\

Para terminar la parte de funciones, vamos a hacer un ejercicio de qu\'imica anal\'itica. Conocemos que existen \'acidos d\'ebiles y que estos se disocian parcialmente en agua. Sin embargo, la cantidad del \'acido d\'ebil o de su base conjugada en el medio depende mucho del pH. Vamos a estudiar una funci\'on que nos va a generar todas las concentraciones de \'acidos d\'ebiles y bases conjugadas para toda la escala de pH. Al graficar estos datos en Miscrosoft Excel o LibreOffice Calc vamos a obtener lo que se conoce como un diagrama de especiaci\'on. Pero para poder ver los datos en una hoja de c\'alculo, debemos guardar estos datos en un documento. Veamos ahora la funci\'on, prob\'emosla y analicemos qu\'e est\'a haciendo y c\'omo.

\begin{Code}
def especiacion(*args):\\
\hspace*{6mm} f = open("diagrama.csv","w")\\
\hspace*{6mm} for i in xrange(0,141,5):\\
\hspace*{13mm} spec = len(args) + 1\\
\hspace*{13mm} ctrl = [0]*spec\\
\hspace*{13mm} for j in xrange(spec):\\
\hspace*{21mm} if j >\ 1:\\
\hspace*{28mm} ctrl[j] = args[j-1]*ctrl[j-1]/(args[j-1] + 10**(i*-0.1))\\
\hspace*{28mm} ctrl[j-1] -= ctrl[j]\\
\hspace*{21mm} elif j == 1:\\
\hspace*{28mm} ctrl[j] = args[j-1]/(args[j-1] + 10**(i*-0.1))\\
\hspace*{28mm} ctrl[j-1] -= ctrl[j]\\
\hspace*{21mm} else:\\
\hspace*{28mm} ctrl[j] = 1\\
\hspace*{13mm} result = str(i*0.1)\\
\hspace*{13mm} for k in ctrl:\\
\hspace*{21mm} result += "\ "\ + str(k)\\
\hspace*{13mm} f.write(result + "\textbackslash n")\\
\hspace*{6mm} f.close()
\end{Code}

Para ejecutarla, podemos hacerlo de la siguiente forma: \inlinecode{especiacion(1.8E-5)} lo cual calcular\'a la cantidad de \'acido ac\'etico y acetato a diferente pH. Tambi\'en podemos probarla as\'i: \inlinecode{especiacion(7.5E-3, 6.2E-8, 4.8E-13)} Esto resultar\'a en el c\'alculo de las especies de fosfatos a diferente pH. Estudiemos la funci\'on y coment\'emosla con nuestro compa\~nero de al lado. Nuevamente, no nos enfoquemos en cada detalle, sino en comprender la idea general.\\

Existen tres cosas importantes en esta funci\'on que acabamos de ver. La primera es que, al igual que la funci\'on que nos mostraba tablas de datos, esta no devuelve nada que le sirva a nuestro ordenador; todo lo almacena en un documento. La segunda es la manera en que colocamos los par\'ametros de la funci\'on\footnote{El nombre de la variable que vamos a usar dentro de la funci\'on. O mejor dicho, el nombre de la variable que va a almacenar a nuestros argumentos.}. Al haber colocaldo un asterisco antes del par\'ametro, la funci\'on ahora toma cualquier cantidad de argumentos. Puede ser uno, pueden ser 3, pueden ser 5 o 10, no importa. El asunto es que nuestra funci\'on es capaz de trabajar con cualquier n\'umero de argumentos, porque al incluir un asterisco, lo que pasar\'a es que Python crear\'a una lista con todo lo que coloquemos como argumentos y la funci\'on trabajar\'a con esa lista. La tercera es que si no escribimos nombres de variables significativos (que se entiendan por personas) y si no documentamos bien nuestro c\'odigo, \textbf{nadie} lo entender\'a. La idea no es que escribamos c\'odigo que funcione, sino que escribamos c\'odigo que funciona en nuestro ordenador, pero pueda ser comprendido por personas.

\subsubsection{Nuestros Paquetes}
Despu\'es de alg\'un tiempo, es com\'un que nos hallemos con decenas, si no cientos de documentos con peque\~nos scripts o programas que nos permit\'ian hacer algo en particular. Si nos portamos un poco m\'as ordenados, vamos colocando diferentes documentos en carpetas separ\'andolos por sus funciones o por lo que hacen. Pero igual, esto sigue siendo un poco de desastre, porque cada vez que necesitamos una funci\'on vamos a tener que ir a ese documento, copiarla, pegarla en donde estamos trabajando y luego utilizarla. Para evitar el desorden y el copiar y pegar, vamos a aprender a crear nuestros propios paquetes.\\

Un paquete no es m\'as que un documento con muchas funciones. As\'i de sencillo! No tenemos que complicarnos m\'as. Si dise\~namos muchas funciones para hacer operaciones de estad\'istica o de \'algebra, lo \'unico que debemos hacer es colocar todas esas funciones en un documento, guardarlo y ya: ese es nuestro nuevo paquete. Para utilizarlo solo debemos tener ese documento en el mismo lugar que el documento que vamos a estar trabajando. Finalmente, importamos con el nombre del documento. Veamos un ejemplo para entender mejor.\\

Vamos a tener nuestras tres funciones de estad\'istica. Una para calcular la media, una para la desviaci\'on est\'andar y una para la mediana.

\begin{Code}
def media(*datos):\\
\hspace*{6mm} return sum(datos)/len(float(datos))\\
\ \\
def des\_std(*datos):\\
\hspace*{6mm} m = media(datos)\\
\hspace*{6mm} diferencia\_cuadrados = sum([(i - m)**2 for i in datos])\\
\hspace*{6mm} varianza = diferencia\_cuadrados / (len(datos) - 1)\\
\hspace*{6mm} return varianza**0.5\\
\ \\
def mediana(*datos):\\
\hspace*{6mm} largo = len(datos)\\
\hspace*{6mm} centro = largo / 2\\
\hspace*{6mm} if largo \% 2 == 0:\\
\hspace*{13mm} return media(datos[centro - 1], datos[centro])\\
\hspace*{6mm} else:\\
\hspace*{13mm} return datos[centro - 1]
\end{Code}

Esto lo vamos a guardar en un documento llamado \emph{estadisticos.py}. Posteriormente, vamos a crear otro documento a la par de este en donde vamos a incluir las siguientes 4 l\'ineas:

\begin{Code}
import estadisticos as stat\\
muestreo = [6.66, 9.751, 10.112, 10.03, 9.01, 13.948, 13.33, 6.096, 7.585, 11.914, 13.037, 4.872, 7.315, 9.24, 11.266, 9.276, 11.228, 11.629, 9.298, 15.026, 3.772, 11.131, 7.46, 8.193, 15.686, 8.428, 1.019, 10.978, 7.13, 11.602, 7.683, 13.229, 14.394, 7.0, 10.243, 11.1, 8.642, 11.586, 9.933, 7.703, 9.753, 13.589, 2.959, 9.956, 13.172, 7.277, 9.216, 15.341, 15.295, 8.211]\\
print "La media de los datos es:", stat.media(muestreo)\\
print "La desviacion estandar de los datos es:", stat.des\_std(muestreo)\\
print "La mediana de los datos es:", stat.mediana(muestreo)\\
\end{Code}

Como nos podemos dar cuenta, esto simplifica muchas cosas. Podemos importar cualquier cantidad de paquetes de Python o creados por nosotros y hacer con ellos lo que se nos ocurra. Es por eso que a continuaci\'on vamos a mostrar realmente la capacidad de los paquetes de Python.

\subsection{M\'as All\'a}
Hasta ahora solo hemos visto bastantes cosas ya. Podemos hacer operaciones matem\'aticas, tareas repetitivas, tomar decisiones, solicitar y leer datos, escribir datos y mostrarlos. Podemos trabajar con paquetes, con diferentes tipos de datos y somos capaces de hallar errores. Es bastante, y sin embargo, ahorita solo hemos visto lo esencial y b\'asico.\\

A continuaci\'on vamos a cambiar un poco la din\'amica del taller. Vamos a ir viendo un ejemplo de diferentes cosas que se pueden hacer con Python. No nos preocupemos si no entendemos todo el c\'odigo a\'un. Esto es solo para formarnos una idea de lo que se puede hacer. Las posibilidades son, realmente, mucho mayores.

\subsubsection{Matem\'atica Avanzada}
Comencemos nuevamente con lo b\'asico. En las ciencias siempre recurrimos a la matem\'atica como lenguaje para nuestros modelos. Hasta ahora hemos visto c\'omo trabajar con n\'umeros. Pero no ser\'ia interesante poder trabajar con \'algebra y c\'alculo? Intentemos replicar el siguiente ejemplo.

\begin{Code}
from sympy import * \# Importamos el paquete de matematica simbolica\\
x = Symbol("x") \# Declaramos a x como un simbolo\\
f = x**3 - 5*x**2 + 3*x + sin(x) \# Definimos una funcion matematica
\end{Code}

Hasta ahora todo bien. De hecho, eso de trabajar con variables simb\'olicas suena prometedor. Nos da la idea de que vamos a poder escribir expresiones algebr\'aicas. Eso es, de hecho, cierto. Pero esta vez vamos a ir m\'as all\'a. Probemos entonces las siguientes 4 cosas.

\begin{Code}
diff(f, x) \# Derivamos la funcion f con respecto de x\\
integrate(f, x) \# Integramos la funcion f con respecto de x de manera indefinida\\
integrate(f, (x, 0, 3)) \# Integramos la funcion f con respecto de x desde 0 hasta 3\\
f.series(x, 0, 10) \# Calculamos la expansion de f como serie de potencias
\end{Code}

Claro, en el tercer caso no nos deja muy contentos que el resultado no sea num\'erico. Pero para eso hay una soluci\'on tambi\'en. El tercer paso lo podemos re-escribir de la siguiente manera: \inlinecode{integrate(f, (x,0,3)).evalf()} Esto nos deber\'ia de llevar a nuestro resultado esperado. Para evaluar qu\'e tan buena aproximaci\'on es el cuarto caso, podemos sustituir $x$ por un n\'umero. Primero veamos qu\'e pasa con la funci\'on: \inlinecode{f.subs(x, 2).evalf()} Ahora pasaremos con la expansi\'on en series de potencias. Pero, si nos damos cuenta, existe un t\'ermino al final de la serie que no nos interesa ahora\footnote{Se trata de un t\'ermino de Landau que representa el resto de la serie valuada en 0.}. Para ello vamos a quitarlo con otra funci\'on y luego evaluar:\\
\inlinecode{f.series(x, 0, 10).removeO().subs(x, 2).evalf()}\\

Poder hacer c\'alculo ya nos permite resolver muchos de aquellos problemas de optimizaci\'on que ten\'iamos. En especial si mencionamos que el paquete \emph{SymPy} tambi\'en nos permite hacer \'algebra b\'asica, resolver ecuaciones y resolver ecuaciones diferenciales. Este paquete contiene cientos, si no miles de funciones que nos permiten hacer muchas operaciones diferentes. Pero no nos limitaremos a este paquete nada m\'as. El paquete \emph{NumPy} nos permite trabajar con arreglos de datos con mucha mayor velocidad a la normal.\\

Un ejemplo cl\'asico en qu\'imica es cuando deseamos balancear una reacci\'on y decidimos utilizar matrices (porque queremos que nuestro ordenador haga el trabajo y no nosotros). Entonces, si tenemos un problema as\'i:

\begin{equation}
a C_5 H_{12} O + b O_2 \longrightarrow c CO_2 + d H_2 O
\end{equation}

La idea ser\'a hallar los coeficientes $a, b, c$ y $d$. Para eso planteamos el sistema de ecuaciones:

\begin{eqnarray}
C: & 5 \cdot a + 0 \cdot b = 1 \cdot c + 0 \cdot d\\
H: & 12 \cdot a + 0 \cdot b = 0 \cdot c + 2 \cdot d\\
O: & 1 \cdot a + 2 \cdot b = 2 \cdot c + 1 \cdot d
\end{eqnarray}

Y aqu\'i es precisamente donde todo se pone interesante en el ordenador. Pasamos todos los coeficientes con $c$ del lado izquierdo de la ecuaci\'on y procedemos a calcular como una matriz de la forma:

\begin{equation}
\left|
\begin{matrix}
5 & 0 & -1 & 0\\
12 & 0 & 0 & 2\\
1 & 2 & -2 & 1
\end{matrix}
\right|
\end{equation}

En donde la \'ultima columna de la matriz es el vector de soluciones. Procedemos entonces a pasar esto a nuestro ordenador y dejar que \'el calcule todo.

\begin{Code}
from numpy import *\\
from numpy.linalg import *\\
mat = array([[5, 0, -1], [12, 0, 0], [1, 2, -2]])\\
vec = array([[0],[2],[1]])\\
solve(mat, vec)
\end{Code}

Claro, el resultado no nos va a dar algo bonito de entrada; este tiene decimales que no nos gustan en coeficientes de reaciones. Por ello, lo vamos a multiplicar por algunos n\'umeros hasta que lleguemos a enteros. Finalmente vamos a hallar, en forma de vector, que los coeficientes que busc\'abamos est\'an para $a, b$ y $c$. En el caso de $d$, pues es claro: $d$ es el producto de los n\'umeros por los que multiplicamos el vector de resultado. Perfecto! Resolvimos un sistema de ecuaciones de 3x3 en segundos y sin mayor problema.\\

\emph{NumPy} es, claramente, capaz de hacer mucho m\'as. Calcula valores y vectores propios, inversas, transpuestas, etc. La ventaja es su velocidad de operaciones para arreglos. Pero bien, debemos aclarar que estos dos paquetes son parte de un proyecto m\'as grande llamado \emph{SciPy} para c\'alculos cient\'ificos. Este tambi\'en cuenta con paquetes para algoritmos, matem\'atica avanzada, visualizaci\'on de datos (hacer gr\'aficas), etc. La idea ser\'a investigarlos y ver qu\'e podemos hacer con ellos. Pero por ahora, vamos a enfocarnos en qu\'imica.

\subsubsection{Qu\'imica en el Ordenador}
Hasta ahora lo m\'as interesante que hab\'iamos hecho a nivel molecular era jugar con el formato SMILES. Esta vez, sin embargo, vamos a hacer otra serie de operaciones con nuestra mol\'ecula. Ahora s\'i haremos algo m\'as que representarla.

\begin{footnotesize}
\begin{Code}
\# Importamos un paquete para herramientas de quimica\\
from rdkit import Chem\\
\ \\
\# Importamos mas herramientas\\
from rdkit.Chem import AllChem \\
\ \\
\# Creamos nuestra molecula en SMILES\\
paracetamol = "\ \hspace*{-2mm}CC(=O)NC1=CC=C(O)C=C1"\\
\ \\
\# La convertimos en molecula para poderla trabajar\\
mol = Chem.MolFromSmiles(paracetamol)\\
\ \\
\# Le agregamos los hidrogenos que nos hacen falta\\
mol\_2 = Chem.AddHs(mol)\\
\ \\
\# Calculamos coordenadas iniciales para una molecula\\
AllChem.EmbedMolecule(mol\_2)\\
\ \\
\# Establecemos los parametros necesarios para determinar la energia de la molecula\\
ff = AllChem.UFFGetMoleculeForceField(mol\_2)\\
\ \\
\# Hallamos la conformacion mas estable de la molecula\\
ff.Minimize()\\
\ \\
\# Solicitamos el valor de energia de la molecula\\
ff.CalcEnergy()\\
\ \\
\# Guardamos nuestra molecula con sus coordenadas 3D en otro formato\\
Chem.MolToMolFile(mol\_2, "\ \hspace*{-2mm}acetaminofen.mol")
\end{Code}
\end{footnotesize}

Como nos podemos dar cuenta, nuestro ordenador ya hace muchas cosas por nosotros: agregar hidrogenos, hallar la conformaci\'on m\'as estable y calcular la energ\'ia (en kJ/mol) de esa mol\'ecula. Claro, esa energ\'ia es muy relativa; fue calculada para esa mol\'ecula nada m\'as y no deber\'iamos usarla como par\'ametro termodin\'amico est\'andar, por ejemplo.\\

Adem\'as de esto, \emph{RDKit} puede calcular las cargas parciales de cada \'atomo, el coeficiente de partici\'on octanol/agua, huellas digitales moleculares, \'indices de similitud entre mol\'eculas, puede hallar subestructuras, etc. Este paquete todav\'ia es un trabajo en progreso, por lo que podemos hallar peque\~nos errores en el programa de vez en cuando. Pero en general, ya nos deja hacer muchas cosas.\\

Otros paquetes para qu\'imica que vale la pena sean mencionados son: \emph{PyQuante} para mec\'anica cu\'antica, \emph{Indigo} que es similar a \emph{RDKit}, \emph{OpenBabel} que nos permite casi cualquier transformaci\'on de formatos adem\'as de algunas herramientas, \emph{MMTK} que ofrece herramientas para trabajos un poco m\'as pesados, y claro, \emph{Cinfony} que combina a muchos de estos paquetes en uno solo.

\subsection{Paquete para Qu\'imica sin usar Fortran, Java, C o C++}
Una desventaja de todos estos paquetes para matem\'atica y qu\'imica es que est\'an solo parcialmente escritos en Python. Otras partes de los mismos est\'an escritos en C, C++, Fortran o Java. Eso los hace m\'as dif\'iciles para nosotros, porque no podemos ver el c\'odigo fuente y adaptarlo a nuestras necesidades. Un proyecto en donde se hiciera un paquete para qu\'imica 100\% en Python ser\'ia una iniciativa totalmente nueva que ayudar\'ia mucho en el proceso de ense\~nanza. Despu\'es de todo, la teor\'ia para todos estos procesos ya est\'a planteada. Y si el problema es de velocidad de operaciones, existe el proyecto \emph{PyPy} que nos ayuda con eso.

\subsection{Comentarios Finales}
Muchas felicidades! Has completado el quinto d\'ia del $TC^3 Q$. Ahora est\'as en la capacidad de crear rutinas peque\~nas, trabajar con lo que te ingrese un usuario, con el contenido de un documento, hacer tareas repetitivas, guardar datos, mostrarlos, hacer operaciones matem\'aticas y trabajar con texto. Adem\'as de ello, ya sabes que tu ordenador puede hacer \'algebra, c\'alculo y hasta \'algebra lineal. Pero lo m\'as importante es que ya comenzaste a ver que tambi\'en se pueden hacer cosas con qu\'imica.\\

Python es un lenguaje muy utilizado por la comunidad cient\'ifica por su capacidad para hacer scripts con \'el, as\'i como su capacidad de hacer programas enteros con \'el. La ventaja es siempre que es bastante f\'acil de aprender y de trabajar con \'el. Por eso mismo, ser\'ia muy conveniente que profundizaras m\'as en los paquetes que ya mencionamos aqu\'i, as\'i como en otros paquetes que te permiten hacer muchas m\'as cosas. Desde hacer juegos, hasta programar servidores. Desde dise\~nar ventanitas para ver cosas, hasta visualizar mol\'eculas en 3D. Desde trabajar con bases de datos desde Python, hasta hacer operaciones en m\'as de 2 procesadores a la vez. Python puede hacer todo esto, solo te toca aprender c\'omo. Los usos que le puedes dar a esto son casi infinitos.\\

De nuevo felicitaciones por haber terminado esta sesi\'on; es una de las m\'as intensas del taller. La semana entrante comenzaremos otra vez de manera un poco m\'as f\'acil, pero tomando en cuenta todo lo que aprendimos esta semana. Esta vez ya comenzaremos a ver cosas que se hacen en computaci\'on cient\'fica. As\'i que repasa un poco y rel\'ajate en el fin de semana. Esto que viene es la mejor parte!

\section*{Licencia}

\noindent \includegraphics{img/cc_big.png}

\noindent Taller de Computaci\'on Cient\'ifica para Ciencias Qu\'imicas by \href{http://github.com/zronyj/TQCA}{Rony J. Letona} is licensed under a \href{http://creativecommons.org/licenses/by-sa/4.0/}{Creative Commons Attribution-ShareAlike 4.0 International License}.

\end{document}
